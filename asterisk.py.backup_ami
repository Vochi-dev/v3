# -*- coding: utf-8 -*-
"""
Asterisk Call Management Service
–°–µ—Ä–≤–∏—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–≤–æ–Ω–∫–∞–º–∏ –Ω–∞ —É–¥–∞–ª–µ–Ω–Ω—ã—Ö Asterisk —Ö–æ—Å—Ç–∞—Ö
–ü–æ—Ä—Ç: 8018
"""

import uvicorn
from fastapi import FastAPI, HTTPException, Query
from fastapi.responses import JSONResponse
import asyncpg
import logging
import socket
import time
from typing import Dict, Optional, Tuple
import asyncio
from datetime import datetime

from app.config import POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB, POSTGRES_HOST, POSTGRES_PORT

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Asterisk Call Management API",
    description="–°–µ—Ä–≤–∏—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–≤–æ–Ω–∫–∞–º–∏ —á–µ—Ä–µ–∑ —É–¥–∞–ª–µ–Ω–Ω—ã–µ Asterisk —Ö–æ—Å—Ç—ã",
    version="1.0.0"
)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ë–î
DB_CONFIG = {
    "user": POSTGRES_USER,
    "password": POSTGRES_PASSWORD,
    "database": POSTGRES_DB,
    "host": POSTGRES_HOST,
    "port": POSTGRES_PORT,
}

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —É–¥–∞–ª–µ–Ω–Ω—ã—Ö Asterisk —Ö–æ—Å—Ç–æ–≤
ASTERISK_CONFIG = {
    "ssh_port": 5059,
    "ami_port": 5038,
    "ami_user": "testoriginate",  # –ù—É–∂–Ω–æ –±—É–¥–µ—Ç —Å–æ–∑–¥–∞—Ç—å –Ω–∞ –≤—Å–µ—Ö —Ö–æ—Å—Ç–∞—Ö
    "ami_password": "test123456",
    "ssh_user": "root",
    "ssh_password": "5atx9Ate@pbx"
}

async def get_db_connection():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î"""
    try:
        return await asyncpg.connect(**DB_CONFIG)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î: {e}")
        raise HTTPException(status_code=500, detail="Database connection error")

async def validate_client_secret(client_id: str, conn: asyncpg.Connection) -> Optional[Dict]:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ clientId –ø—Ä–æ—Ç–∏–≤ secret –∏–∑ —Ç–∞–±–ª–∏—Ü—ã enterprises"""
    try:
        query = """
        SELECT number, name, ip 
        FROM enterprises 
        WHERE secret = $1 AND active = true
        """
        result = await conn.fetchrow(query, client_id)
        
        if result:
            return {
                "enterprise_number": result["number"],
                "name": result["name"],
                "host_ip": result["ip"]
            }
        return None
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ clientId: {e}")
        return None

def ami_originate_call(host_ip: str, from_ext: str, to_phone: str) -> Tuple[bool, str]:
    """–ò–Ω–∏—Ü–∏–∞—Ü–∏—è –∑–≤–æ–Ω–∫–∞ —á–µ—Ä–µ–∑ AMI –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å"""
    try:
        # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ AMI
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)  # 10 —Å–µ–∫—É–Ω–¥ —Ç–∞–π–º–∞—É—Ç
        sock.connect((host_ip, ASTERISK_CONFIG["ami_port"]))
        
        # –ß–∏—Ç–∞–µ–º –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ
        response = sock.recv(1024).decode()
        logger.info(f"AMI –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –æ—Ç {host_ip}: {response[:100]}")
        
        # –õ–æ–≥–∏–Ω
        login_cmd = f"Action: Login\r\nUsername: {ASTERISK_CONFIG['ami_user']}\r\nSecret: {ASTERISK_CONFIG['ami_password']}\r\n\r\n"
        sock.send(login_cmd.encode())
        time.sleep(0.5)
        
        response = sock.recv(1024).decode()
        if "Success" not in response:
            sock.close()
            return False, f"AMI login failed: {response[:200]}"
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ActionID
        action_id = f"webhook_{int(time.time())}_{from_ext}"
        
        # –ö–æ–º–∞–Ω–¥–∞ Originate
        originate_cmd = f"""Action: Originate
Channel: Local/{from_ext}@inoffice
Context: inoffice
Exten: {to_phone}
Priority: 1
CallerID: WebHook-{from_ext}
Timeout: 30000
ActionID: {action_id}

"""
        
        logger.info(f"–û—Ç–ø—Ä–∞–≤–ª—è–µ–º AMI –∫–æ–º–∞–Ω–¥—É –¥–ª—è {host_ip}: {from_ext} -> {to_phone}")
        sock.send(originate_cmd.encode())
        time.sleep(1)
        
        # –ß–∏—Ç–∞–µ–º –æ—Ç–≤–µ—Ç
        response = sock.recv(2048).decode()
        
        # Logout
        logout_cmd = "Action: Logoff\r\n\r\n"
        sock.send(logout_cmd.encode())
        sock.close()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Ç–≤–µ—Ç
        if "Response: Success" in response:
            logger.info(f"‚úÖ –ó–≤–æ–Ω–æ–∫ —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–Ω: {from_ext} -> {to_phone} –Ω–∞ {host_ip}")
            return True, f"Call initiated successfully: {from_ext} -> {to_phone}"
        else:
            logger.warning(f"‚ùå AMI originate failed: {response[:300]}")
            return False, f"AMI originate failed: {response[:200]}"
            
    except socket.timeout:
        logger.error(f"–¢–∞–π–º–∞—É—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ AMI –Ω–∞ {host_ip}")
        return False, f"Connection timeout to {host_ip}"
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ AMI –Ω–∞ {host_ip}: {e}")
        return False, f"AMI error: {str(e)}"

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "service": "asterisk-call-management", "port": 8018}

@app.get("/api/makecallexternal")
async def make_call_external(
    code: str = Query(..., description="–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –Ω–æ–º–µ—Ä"),
    phone: str = Query(..., description="–ù–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞"),
    clientId: str = Query(..., description="Client ID (secret –∏–∑ enterprises)")
):
    """
    –ò–Ω–∏—Ü–∏–∞—Ü–∏—è –≤–Ω–µ—à–Ω–µ–≥–æ –∑–≤–æ–Ω–∫–∞
    
    –ü–∞—Ä–∞–º–µ—Ç—Ä—ã:
    - code: –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –Ω–æ–º–µ—Ä (–Ω–∞–ø—Ä–∏–º–µ—Ä: 150, 151)
    - phone: –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: +375296254070)
    - clientId: secret –∏–∑ —Ç–∞–±–ª–∏—Ü—ã enterprises
    
    –ü—Ä–∏–º–µ—Ä:
    GET /api/makecallexternal?code=150&phone=+375296254070&clientId=eb7ba607633a47af8edc9b8d257d29e4
    """
    
    start_time = time.time()
    
    try:
        logger.info(f"üöÄ –ó–∞–ø—Ä–æ—Å –Ω–∞ –∑–≤–æ–Ω–æ–∫: {code} -> {phone}, clientId: {clientId[:8]}...")
        
        # –í–∞–ª–∏–¥–∞—Ü–∏—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
        if not code or not phone or not clientId:
            raise HTTPException(
                status_code=400, 
                detail="–í—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã: code, phone, clientId"
            )
        
        # –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î
        conn = await get_db_connection()
        
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º clientId
            enterprise_info = await validate_client_secret(clientId, conn)
            
            if not enterprise_info:
                logger.warning(f"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π clientId: {clientId}")
                raise HTTPException(
                    status_code=401, 
                    detail="Invalid clientId"
                )
            
            logger.info(f"‚úÖ –ö–ª–∏–µ–Ω—Ç –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω: {enterprise_info['name']} ({enterprise_info['enterprise_number']})")
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ host_ip
            host_ip = enterprise_info.get("host_ip")
            if not host_ip:
                logger.error(f"‚ùå –ù–µ —É–∫–∞–∑–∞–Ω host_ip –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_info['enterprise_number']}")
                raise HTTPException(
                    status_code=500, 
                    detail="Host IP not configured for this enterprise"
                )
            
            # –ò–Ω–∏—Ü–∏–∏—Ä—É–µ–º –∑–≤–æ–Ω–æ–∫ —á–µ—Ä–µ–∑ AMI
            success, message = ami_originate_call(host_ip, code, phone)
            
            if success:
                # –õ–æ–≥–∏—Ä—É–µ–º —É—Å–ø–µ—à–Ω—ã–π –∑–≤–æ–Ω–æ–∫ –≤ –ë–î (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
                try:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã call_logs
                    table_exists = await conn.fetchval("""
                        SELECT EXISTS (
                            SELECT FROM information_schema.tables 
                            WHERE table_schema = 'public' 
                            AND table_name = 'call_logs'
                        )
                    """)
                    
                    if table_exists:
                        log_query = """
                        INSERT INTO call_logs (enterprise_number, from_ext, to_phone, status, created_at)
                        VALUES ($1, $2, $3, $4, $5)
                        """
                        await conn.execute(
                            log_query,
                            enterprise_info['enterprise_number'],
                            code,
                            phone,
                            'initiated',
                            datetime.now()
                        )
                    else:
                        logger.info("–¢–∞–±–ª–∏—Ü–∞ call_logs –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ")
                        
                except Exception as log_error:
                    logger.warning(f"–û—à–∏–±–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –∑–≤–æ–Ω–∫–∞: {log_error}")
                
                response_time = round((time.time() - start_time) * 1000, 2)
                
                return JSONResponse(
                    status_code=200,
                    content={
                        "success": True,
                        "message": message,
                        "enterprise": enterprise_info['name'],
                        "enterprise_number": enterprise_info['enterprise_number'],
                        "from_ext": code,
                        "to_phone": phone,
                        "host_ip": host_ip,
                        "response_time_ms": response_time
                    }
                )
            else:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞—Ü–∏–∏ –∑–≤–æ–Ω–∫–∞: {message}")
                raise HTTPException(
                    status_code=500,
                    detail=f"Call initiation failed: {message}"
                )
                
        finally:
            await conn.close()
            
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Internal server error: {str(e)}"
        )

@app.get("/api/status")
async def api_status():
    """–°—Ç–∞—Ç—É—Å API –∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π"""
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î
        conn = await get_db_connection()
        db_status = "connected"
        await conn.close()
    except Exception as e:
        db_status = f"error: {str(e)}"
    
    return {
        "service": "asterisk-call-management",
        "version": "1.0.0",
        "database": db_status,
        "asterisk_config": {
            "ami_port": ASTERISK_CONFIG["ami_port"],
            "ssh_port": ASTERISK_CONFIG["ssh_port"],
            "ami_user": ASTERISK_CONFIG["ami_user"]
        }
    }

if __name__ == "__main__":
    uvicorn.run(
        "asterisk:app",
        host="0.0.0.0",
        port=8018,
        reload=True,
        log_level="info"
    )