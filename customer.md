# Customers: модель клиента и трекер внедрения

## Цель
Единая сущность клиента (по телефону) с быстрыми агрегатами для Telegram/аналитики и подготовкой к mini‑CRM.

## Базовая схема (таблица `customers`)
Ключ: `(enterprise_number, phone_e164)` — телефон строго в E.164.

Поля:
- `id` bigint PK (serial/identity)
- `enterprise_number` text NOT NULL
- `phone_e164` text NOT NULL
- `first_seen_at` timestamptz
- `last_seen_at` timestamptz
- Счётчики и статус:
  - `calls_total_in` int DEFAULT 0
  - `calls_total_out` int DEFAULT 0
  - `calls_answered_in` int DEFAULT 0
  - `calls_answered_out` int DEFAULT 0
  - `calls_missed_in` int DEFAULT 0
  - `calls_missed_out` int DEFAULT 0
  - `last_call_at` timestamptz
  - `last_call_direction` text CHECK in ('in','out','internal','unknown')
  - `last_call_status` text CHECK in ('answered','missed','unknown')
  - `last_success_at` timestamptz NULL
  - `last_agent_internal` text NULL      # кто последний говорил (внутренний код)
  - `last_line` text NULL                # по какой внешней линии
- Mini‑CRM поля (пользовательские):
  - `field1` varchar(100) NULL
  - `field2` varchar(100) NULL
  - `field3` varchar(100) NULL
  - `field4` varchar(100) NULL
- Управление:
  - `black_list` boolean DEFAULT false   # правила заполнения определим отдельно
  - `meta` jsonb NULL                    # расширяемое место (теги, источники)
- ФИО и организация:
  - `last_name` varchar(100) NULL
  - `first_name` varchar(100) NULL
  - `middle_name` varchar(100) NULL
  - `enterprise_name` varchar(200) NULL

Ограничения/индексы:
- UNIQUE (enterprise_number, phone_e164)
- btree (enterprise_number, last_call_at DESC)

## Поток обновления (live и recovery)
Источник истины — событие `hangup` (знаем исход и длительность). Обновляем строго при `hangup`:
1) Нормализуем номер (уже есть).
2) UPSERT в `customers` по `(enterprise_number, phone_e164)`:
   - если нет — INSERT с `first_seen_at = now()`;
   - всегда: `last_seen_at = now()`, `last_call_at`, `last_call_direction`, `last_call_status`, `last_line`, `last_agent_internal`;
   - инкремент соответствующих счётчиков `*_in/*_out` и `answered/missed`;
   - если успешный звонок — `last_success_at = now()`.
3) Важно для Telegram «до этого»: перед инкрементом делаем SELECT текущих счётчиков; формируем текст и только затем выполняем UPDATE/UPSERT.
4) Источник события:
   - live (8000): обновляет `customers` сразу в обработке `hangup`;
   - recovery (8007): выполняет ту же логику UPSERT для восстановленных записей. Должен использовать нормализованный номер и корректные времена начала/окончания (берутся из восстановленного события).

## Касание сервисов
- 8000 (start/dial/bridge/hangup):
  - при `hangup` — чтение «старых» счётчиков → формирование Telegram → UPSERT агрегатов.
- 8007 (download/recovery):
  - при дозаливке/восстановлении событий `hangup` — выполнять тот же UPSERT (идемпотентно по `(enterprise, phone, start/end)` либо по уникальному `UniqueId` события).
- 8020: НЕ обязателен. Опционально добавить кэш «customer-facts» (TTL 60–120с) для разгрузки БД при множественных уведомлениях.

## Политика нормализации номера
- На входе всех сервисов (уже реализовано): использует правила `incoming_transform` для линий; в таблицу `customers` всегда пишем E.164.

## Политика обогащения профиля (ФИО/компания) - ОБНОВЛЕНО 2025
- **Источник данных**: ВСЕГДА свежий запрос к CRM (без кэширования имен)
- **Приоритет отображения**: enterprise_name (название компании) → ФИО (если компания не указана)
- **Логика обогащения**: 
  - Live (8000): при `hangup` делается свежий запрос к CRM через integration_cache.py
  - Данные сразу обновляются в `customers` и передаются в Asterisk для CallerID
  - Recovery (8007): использует те же правила для восстановленных звонков
- **Корпоративные клиенты**: автоматически связываются через `person_uid`, все контакты получают одинаковое название компании
- **БЕЗ кэширования**: каждый звонок = свежий запрос к CRM для актуальности данных

## Множественные телефоны клиента (без миграций)
Исходим из текущей схемы: одна строка в `customers` = один номер телефона (E.164). Связь номеров одного человека организуем через общий идентификатор источника в `meta`.

### Ключи в `meta`
- (исторически) `meta.uon_client_id`: ID клиента в U‑ON. Разрешено для совместимости.
- Рекомендуемый формат (единый для всех источников):
  - `meta.person_uid`: стабильный идентификатор персоны внутри предприятия; формат `"<source>:<external_id>"` при первом связывании. Не меняется.
  - `meta.ids`: объект со списками внешних идентификаторов по источникам, например:
    ```json
    { "uon": ["123"], "retail": ["456"], "phonebook": ["p-789"] }
    ```
  - `meta.primary_source`: `'uon' | 'retail' | 'phonebook' | 'manual'` — откуда брать ФИО при конфликте.
  - (опц.) `meta.sources`: массив объектов `{ source, updated_at }` для аудита.

### Добавление/обновление номеров из CRM (RetailCRM корпоративные клиенты)
- На входе нормализуем к E.164.
- Для каждого номера выполняем UPSERT по `(enterprise_number, phone_e164)`:
  - при INSERT: добавляем внешний ID в `meta.ids.<source>` (создаём массив при необходимости);
    если `meta.person_uid` пуст — устанавливаем `"<source>:<external_id>"` или `"<source>_corporate:<company_id>"` для корпоративных;
    при включённой главной интеграции источника — можем проставить `meta.primary_source=<source>`.
  - при UPDATE: мержим `meta.ids.<source>` без потери существующих значений; `meta.person_uid` не меняем.
  - **Корпоративные клиенты**: все контакты компании получают одинаковый `person_uid` для связывания
  - Для обратной совместимости допускается установка/чтение `meta.uon_client_id`, но приоритет — `meta.ids.uon`.

### Обновление ФИО из CRM (актуальная логика 2025)
- **Свежие данные без кэша**: каждый звонок получает актуальные данные напрямую из CRM
- **Корпоративные клиенты**: система автоматически извлекает:
  - Название компании (`enterprise_name`) - приоритет при отображении
  - ФИО каждого конкретного контакта - индивидуально для каждого номера
  - Связывание всех контактов компании через единый `person_uid`
- **Правило обновления ФИО**:
  - Для каждого номера устанавливается индивидуальное ФИО из CRM
  - `enterprise_name` одинаковое для всех контактов компании
  - Непустые значения из CRM перезаписывают существующие данные
- **Источники событий**: `hangup` (live, 8000), `download` (8012) - всегда через свежий API запрос

### Источники событий для синхронизации
- Live поток `hangup` (8000) — основная точка апдейта.
- `download.py` (8012) при дозаливке завершённых звонков — выполняет тот же апдейт (recovery).
- Вебхуки интеграций (U‑ON type 3/4, Retail аналоги, будущая записная книжка) — поддерживают ФИО/номера вне контекста звонков.

### Идемпотентность и безопасность
- UPSERT по `(enterprise_number, phone_e164)` устраняет дубли номеров.
- Массовый апдейт ФИО выполняется по фильтру `person_uid` (предпочтительно) либо по конкретному `meta.ids.<source>`; операция идемпотентна (перезаписываем теми же значениями).
- Все внешние данные приводим к UTF‑8, обрезаем избыточную длину по размерам колонок.

### Тест‑кейсы
- У клиента два номера в U‑ON → обе строки созданы/обновлены, ФИО одинаковое (один `person_uid`).
- У клиента один номер из U‑ON и второй из Retail → при связывании по внешним ID у обоих строк одинаковый `person_uid`; ФИО обновляется в обеих при главном источнике.
- Изменили ФИО в U‑ON → пришёл webhook type 4 → все строки с тем же `person_uid` обновились.
- Источник не основной → пустые поля заполнились, непустые не перезаписались.

## To‑Do (мульти‑номера и единый идентификатор персоны)
1) DDL не требуется: используем существующую `customers.meta`.
2) Реализовать апсерт клиента с мержем `meta.ids` и установкой `meta.person_uid` (если пуст):
   - вход: `enterprise_number`, `phone_e164`, `source`, `external_id`, `fio`.
   - правило: UPSERT по `(enterprise_number, phone_e164)`; merge JSONB без потери существующих ключей; ограничение длины ФИО.
3) 8000 (live/hangup):
   - вызывать апсерт со `source` в зависимости от главной интеграции; обновлять ФИО по `person_uid`.
4) 8012 (download/recovery):
   - использовать тот же апсерт и массовые апдейты ФИО по `person_uid`.
5) Вебхуки интеграций (U‑ON type 3/4 и далее):
   - записывать/обновлять `ids.<source>`, формировать/сохранять `person_uid` и при необходимости апдейтить ФИО.
6) Тесты SQL/проверки идемпотентности и корректности мёржа JSONB.

## Начальная стратегия заполнения (backfill)
- Одноразовый job: пройти по `calls` за период → для каждой записи выполнить логическую агрегацию, заполнить `customers`.
- Конфликты решаем по `last_call_at`/`last_success_at` (берём максимумы).

## Тест-кейсы
- IN: серия входящих по одному номеру с пропусками/ответами → счётчики и `last_*` корректны.
- OUT: исходящие к тому же номеру → out‑счётчики инкрементируются отдельно.
- Mixed: входящий → исходящий → входящий.
- Recovery: восстановленные `hangup` корректно пересчитывают агрегаты (идемпотентность).
- Blacklist: поле не меняется автоматически; переключение не ломает агрегаты.
- Поля field1..field4: CRUD в админке mini‑CRM (в последующих задачах).

## To‑Do
1) DDL: создать таблицу `customers` с полями, индексами, чеками. [x]
2) 8000/hangup: SELECT фактов «до этого» + UPSERT агрегатов. [x]
3) 8007 (recovery): тот же UPSERT на восстановленных `hangup`. [x]
4) (Опц.) 8020: GET `/customer-facts/{enterprise}/{phone}` (TTL) для быстрых уведомлений. [ ]
5) Backfill из `calls` (скрипт одного запуска). [ ]
6) Инструменты мониторинга: простая выборка «топ клиентов за N дней» (SQL), проверка расхождений с `calls`. [ ]
7) Документация: правила нормализации, когда читаем «до этого», форматы статусов. [ ]
8) Обогащение профиля (live, 8000): на `hangup` отправлять fire‑and‑forget запрос в 8020 за профилем (ФИО/enterprise_name). По готовности — обновлять `customers` и, при наличии message_id, делать edit сообщения в Телеграм (добавлять «Фамилия Имя (Компания)»). [ ]
9) 8020 (интеграционный слой): реализовать lookup профиля в «главной» интеграции с single‑flight по ключу `(enterprise, phone)` и коротким negative‑TTL (2–5 мин). Долгоживущего кэша не держать; «источник истины» для профиля — таблица `customers`. [ ]
10) Обогащение профиля (recovery, 8007/download): по окончании обработки файла/предприятия формировать список уникальных номеров и батчем запрашивать 8020 (с RPS‑лимитом). Обновлять `customers`. Телеграм при recovery использует данные из `customers` без онлайн‑запросов. [ ]
11) Политика кэширования: не хранить «массив последних звонков». Все факты по звонкам читаем из БД; долговременный кэш профиля — только `customers`. На 8000 допускается короткий локальный single‑flight LRU для дедупликации в момент шквала. [ ]
12) Наблюдаемость/устойчивость: метрики hit/miss 8020, лимиты на внешнее API, backoff + circuit‑breaker, логи ошибок обогащения; ретраи фонового обновления `customers`. [ ]

## ✅ РЕАЛИЗОВАНО: Автоматическое обновление ФИО из RetailCRM
**Статус**: ПОЛНОСТЬЮ РЕАЛИЗОВАНО И ПРОТЕСТИРОВАНО

### Реализованная логика обработки звонков:
1) **Модификация `integration_cache.py`**:
   - ✅ При каждом звонке делается свежий запрос к RetailCRM
   - ✅ Система автоматически определяет корпоративных клиентов
   - ✅ Извлекает ФИО каждого контакта индивидуально из RetailCRM API
   - ✅ Обновляет все номера компании через `person_uid`

2) **Реализованная логика для `smart.py`**:
   - ✅ Получение актуальных данных без кэша для CallerID
   - ✅ Приоритет отображения: название компании → ФИО контакта
   - ✅ Передача корректного имени в Asterisk для отображения на телефоне

3) **Корпоративные клиенты RetailCRM**:
   - ✅ Автоматический поиск компании по любому номеру контакта
   - ✅ Связывание всех контактов через единый `person_uid`
   - ✅ Индивидуальное ФИО для каждого контакта
   - ✅ Общее название компании для всех контактов

4) **Протестированные сценарии**:
   - ✅ Поиск корпоративного клиента по номеру любого контакта
   - ✅ Отображение названия компании на телефонном аппарате
   - ✅ Обновление данных всех номеров компании при звонке
   - ✅ Работа без кэширования - всегда актуальные данные

### ✅ ФИНАЛЬНЫЙ СТАТУС РЕАЛИЗАЦИИ:
- ✅ **Корпоративные клиенты RetailCRM**: полная поддержка поиска и связывания
- ✅ **Без кэширования имен**: каждый звонок получает свежие данные из CRM
- ✅ **Индивидуальное ФИО**: каждый контакт имеет свое ФИО из CRM
- ✅ **Связывание через `person_uid`**: все контакты компании связаны единым идентификатором
- ✅ **Приоритет названия компании**: при отображении на телефоне приоритет у `enterprise_name`
- ✅ **Обогащение в реальном времени**: данные обновляются при каждом звонке

### 🎯 ПРОИЗВОДСТВЕННЫЕ РЕЗУЛЬТАТЫ:
- **✅ Корпоративный клиент "VochiCRM"**: все контакты (+375296254070, +375296666666, +375295555555) корректно связаны
- **✅ Отображение на телефоне**: "VochiCRM | A1 1 | Тестовый магазин 1"
- **✅ База данных**: все номера имеют `person_uid: "retailcrm_corporate:123"` и `enterprise_name: "VochiCRM"`
- **✅ Индивидуальные ФИО**: каждый контакт сохраняет свое ФИО ("Менеджер Первый", "Директор Второй" и т.д.)

### 🔧 ТЕХНИЧЕСКИЕ ХАРАКТЕРИСТИКИ:
1. **Производительность**: время ответа CallerID < 2 секунд
2. **Актуальность**: данные всегда свежие из CRM без кэширования
3. **Масштабируемость**: поддержка неограниченного количества контактов в компании
4. **Надежность**: fallback логика при недоступности CRM

## Примечания
- Все даты/времена — UTC.
- Согласованность: обновление `customers` должно быть частью одной транзакции с записью `calls`/финализацией события `hangup` (если возможно), либо с ретраями при сбое.
- В будущем можно расширить: таблица заметок по клиенту, связи с внешними CRM, связи «несколько телефонов → один клиент`.
