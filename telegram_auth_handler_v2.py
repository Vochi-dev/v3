#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Telegram Auth Handler Ð´Ð»Ñ aiogram 2.x
ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ð´Ð»Ñ Telegram-Ð±Ð¾Ñ‚Ð¾Ð² Ð¿Ñ€ÐµÐ´Ð¿Ñ€Ð¸ÑÑ‚Ð¸Ð¹
"""

import re
import logging
from typing import Optional
import httpx
from aiogram import Bot, Dispatcher, types
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.dispatcher.filters import Text, Command

logger = logging.getLogger(__name__)

# URL Ð½Ð°ÑˆÐµÐ³Ð¾ telegram_auth_service
TELEGRAM_AUTH_SERVICE_URL = "http://localhost:8016"

class TelegramAuth(StatesGroup):
    """Ð¡Ð¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ð² Telegram"""
    waiting_email = State()
    waiting_code = State()

def register_auth_handlers(dp: Dispatcher, enterprise_number: str):
    """Ð ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€ÑƒÐµÑ‚ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐ¸ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸ Ð² dispatcher"""
    
    @dp.message_handler(commands=['start'])
    async def cmd_start(message: types.Message, state: FSMContext):
        """
        ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /start
        Ð’ÑÐµÐ³Ð´Ð° Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸ÑŽ Ð¸ Ð¿Ñ€ÐµÐ´Ð»Ð°Ð³Ð°ÐµÑ‚ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð¾Ð²Ð°Ñ‚ÑŒÑÑ ÐµÑÐ»Ð¸ Ð½ÑƒÐ¶Ð½Ð¾
        """
        user_id = message.from_user.id
        username = message.from_user.username or "ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ"
        
        # Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ enterprise_number Ð¸Ð· Ð²Ð½ÐµÑˆÐ½ÐµÐ¹ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸
        current_enterprise = enterprise_number
        logger.info(f"Enterprise number: {current_enterprise}")
        
        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ ÑÑÑ‹Ð»ÐºÐ¸ (ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ)
        web_user_id = ""
        args = message.get_args()
        if args and args.startswith("auth_"):
            # ÐŸÐ°Ñ€ÑÐ¸Ð¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¸Ð· ÑÑÑ‹Ð»ÐºÐ¸
            match = re.match(r"auth_(\d*)_(\w+)", args)
            if match:
                web_user_id, link_enterprise = match.groups()
                # Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ enterprise Ð¸Ð· ÑÑÑ‹Ð»ÐºÐ¸ ÐµÑÐ»Ð¸ ÑƒÐºÐ°Ð·Ð°Ð½, Ð¸Ð½Ð°Ñ‡Ðµ Ñ‚ÐµÐºÑƒÑ‰Ð¸Ð¹
                if link_enterprise:
                    current_enterprise = link_enterprise
        
        enterprise_name = await get_enterprise_name(current_enterprise) if current_enterprise else "june"
        
        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð¾Ð²Ð°Ð½ Ð»Ð¸ ÑƒÐ¶Ðµ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ
        is_authorized = await check_user_authorization(user_id)
        
        if is_authorized:
            # ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ÑƒÐ¶Ðµ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð¾Ð²Ð°Ð½ - Ð¿Ñ€Ð¸Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ðµ
            await message.answer(
                f"âœ… Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ Ð² Telegram-Ð±Ð¾Ñ‚ Ð¿Ñ€ÐµÐ´Ð¿Ñ€Ð¸ÑÑ‚Ð¸Ñ {enterprise_name}!\n\n"
                f"Ð’Ñ‹ ÑƒÐ¶Ðµ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð¾Ð²Ð°Ð½Ñ‹ Ð² ÑÐ¸ÑÑ‚ÐµÐ¼Ðµ.\n"
                f"Ð—Ð´ÐµÑÑŒ Ð²Ñ‹ Ð±ÑƒÐ´ÐµÑ‚Ðµ Ð¿Ð¾Ð»ÑƒÑ‡Ð°Ñ‚ÑŒ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ Ð¾ Ð·Ð²Ð¾Ð½ÐºÐ°Ñ… Ð¸ Ð´Ñ€ÑƒÐ³Ð¸Ñ… ÑÐ¾Ð±Ñ‹Ñ‚Ð¸ÑÑ….\n\n"
                f"ðŸ“ž Ð¢ÐµÑ…Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ°: @VochiSupport"
            )
        else:
            # ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ÐÐ• Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð¾Ð²Ð°Ð½ - Ð¿Ñ€ÐµÐ´Ð»Ð°Ð³Ð°ÐµÐ¼ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸ÑŽ
            await message.answer(
                f"ðŸ” Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ Ð² Telegram-Ð±Ð¾Ñ‚ Ð¿Ñ€ÐµÐ´Ð¿Ñ€Ð¸ÑÑ‚Ð¸Ñ {enterprise_name}!\n\n"
                f"Ð”Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ð¹ Ð¾ Ð·Ð²Ð¾Ð½ÐºÐ°Ñ… Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð¾Ð²Ð°Ñ‚ÑŒÑÑ.\n\n"
                f"ðŸ‘‡ Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð²Ð°Ñˆ ÐºÐ¾Ñ€Ð¿Ð¾Ñ€Ð°Ñ‚Ð¸Ð²Ð½Ñ‹Ð¹ email Ð´Ð»Ñ Ð½Ð°Ñ‡Ð°Ð»Ð° Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸:"
            )
            
            # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÐ¼ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð² state
            await state.update_data(
                web_user_id=web_user_id,
                enterprise_number=current_enterprise
            )
            
            await TelegramAuth.waiting_email.set()

    @dp.message_handler(state=TelegramAuth.waiting_email)
    async def process_email(message: types.Message, state: FSMContext):
        """ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð²Ð²ÐµÐ´ÐµÐ½Ð½Ð¾Ð³Ð¾ email"""
        email = message.text.strip().lower()
        user_data = await state.get_data()
        
        # Ð‘Ð°Ð·Ð¾Ð²Ð°Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° email
        if "@" not in email or "." not in email:
            await message.answer("âŒ ÐÐµÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ email. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÐµÑ‰Ðµ Ñ€Ð°Ð·:")
            return
        
        try:
            # ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð½Ð° Ð½Ð°Ñ‡Ð°Ð»Ð¾ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{TELEGRAM_AUTH_SERVICE_URL}/start_auth_flow",
                    json={
                        "email": email,
                        "enterprise_number": user_data["enterprise_number"],
                        "telegram_id": message.from_user.id
                    },
                    timeout=30
                )
                
                if response.status_code == 200:
                    result = response.json()
                    if result["success"]:
                        await message.answer(
                            f"âœ… {result['message']}\n\n"
                            f"Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ð¹ 6-Ð·Ð½Ð°Ñ‡Ð½Ñ‹Ð¹ ÐºÐ¾Ð´:"
                        )
                        await state.update_data(email=email)
                        await TelegramAuth.waiting_code.set()
                    else:
                        await message.answer(f"âŒ {result['message']}")
                        await state.finish()
                else:
                    await message.answer("âŒ ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ.")
                    await state.finish()
                    
        except Exception as e:
            logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð·Ð°Ð¿Ñ€Ð¾ÑÐµ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ð¸: {e}")
            await message.answer("âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ Ðº ÑÐµÑ€Ð²ÐµÑ€Ñƒ. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ.")
            await state.finish()

    @dp.message_handler(state=TelegramAuth.waiting_code)
    async def process_code(message: types.Message, state: FSMContext):
        """ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð²Ð²ÐµÐ´ÐµÐ½Ð½Ð¾Ð³Ð¾ ÐºÐ¾Ð´Ð°"""
        code = message.text.strip()
        user_data = await state.get_data()
        
        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð° ÐºÐ¾Ð´Ð°
        if not code.isdigit() or len(code) != 6:
            await message.answer("âŒ ÐšÐ¾Ð´ Ð´Ð¾Ð»Ð¶ÐµÐ½ ÑÐ¾ÑÑ‚Ð¾ÑÑ‚ÑŒ Ð¸Ð· 6 Ñ†Ð¸Ñ„Ñ€. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ ÐµÑ‰Ðµ Ñ€Ð°Ð·:")
            return
        
        try:
            # ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð½Ð° Ð²ÐµÑ€Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸ÑŽ ÐºÐ¾Ð´Ð°
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    f"{TELEGRAM_AUTH_SERVICE_URL}/verify_code",
                    json={
                        "email": user_data["email"],
                        "code": code,
                        "telegram_id": message.from_user.id
                    },
                    timeout=30
                )
                
                if response.status_code == 200:
                    result = response.json()
                    if result["success"]:
                        enterprise_name = await get_enterprise_name(user_data["enterprise_number"])
                        user_name = result["data"]["full_name"]
                        
                        await message.answer(
                            f"ðŸŽ‰ ÐÐ²Ñ‚Ð¾Ñ€Ð¸Ð·Ð°Ñ†Ð¸Ñ ÑƒÑÐ¿ÐµÑˆÐ½Ð°!\n\n"
                            f"Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ, {user_name}!\n"
                            f"Ð’Ñ‹ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð¾Ð²Ð°Ð½Ñ‹ Ð² Telegram-Ð±Ð¾Ñ‚Ðµ Ð¿Ñ€ÐµÐ´Ð¿Ñ€Ð¸ÑÑ‚Ð¸Ñ {enterprise_name}.\n\n"
                            f"Ð¢ÐµÐ¿ÐµÑ€ÑŒ Ð²Ñ‹ Ð±ÑƒÐ´ÐµÑ‚Ðµ Ð¿Ð¾Ð»ÑƒÑ‡Ð°Ñ‚ÑŒ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ Ð¾:\n"
                            f"ðŸ“ž Ð’Ñ…Ð¾Ð´ÑÑ‰Ð¸Ñ… Ð¸ Ð¸ÑÑ…Ð¾Ð´ÑÑ‰Ð¸Ñ… Ð·Ð²Ð¾Ð½ÐºÐ°Ñ…\n"
                            f"ðŸ“‹ Ð’Ð°Ð¶Ð½Ñ‹Ñ… ÑÐ¾Ð±Ñ‹Ñ‚Ð¸ÑÑ… ÑÐ¸ÑÑ‚ÐµÐ¼Ñ‹\n"
                            f"ðŸ“Š ÐžÑ‚Ñ‡ÐµÑ‚Ð°Ñ… Ð¸ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐµ\n\n"
                            f"ðŸ“ž Ð¢ÐµÑ…Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ°: @VochiSupport"
                        )
                    else:
                        await message.answer(f"âŒ {result['message']}")
                else:
                    await message.answer("âŒ ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ.")
                    
            await state.finish()
                    
        except Exception as e:
            logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð²ÐµÑ€Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ð¸ ÐºÐ¾Ð´Ð°: {e}")
            await message.answer("âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ Ðº ÑÐµÑ€Ð²ÐµÑ€Ñƒ. ÐŸÐ¾Ð¿Ñ€Ð¾Ð±ÑƒÐ¹Ñ‚Ðµ Ð¿Ð¾Ð·Ð¶Ðµ.")
            await state.finish()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ð’Ð¡ÐŸÐžÐœÐžÐ“ÐÐ¢Ð•Ð›Ð¬ÐÐ«Ð• Ð¤Ð£ÐÐšÐ¦Ð˜Ð˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def get_enterprise_by_bot_token(bot_token: str) -> Optional[str]:
    """ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð½Ð¾Ð¼ÐµÑ€ Ð¿Ñ€ÐµÐ´Ð¿Ñ€Ð¸ÑÑ‚Ð¸Ñ Ð¿Ð¾ Ñ‚Ð¾ÐºÐµÐ½Ñƒ Ð±Ð¾Ñ‚Ð°"""
    try:
        # ÐŸÑ€ÑÐ¼Ð¾Ð¹ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ðº Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ enterprise_number Ð¿Ð¾ bot_token
        async with httpx.AsyncClient() as client:
            response = await client.post(
                f"{TELEGRAM_AUTH_SERVICE_URL}/get_enterprise_by_token",
                json={"bot_token": bot_token},
                timeout=10
            )
            if response.status_code == 200:
                result = response.json()
                return result.get("enterprise_number")
    except Exception as e:
        logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ enterprise_number: {e}")
    return None

async def get_enterprise_name(enterprise_number: str) -> str:
    """ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€ÐµÐ´Ð¿Ñ€Ð¸ÑÑ‚Ð¸Ñ Ð¸Ð· Ð‘Ð”"""
    try:
        import asyncpg
        
        # ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ðº Ð±Ð°Ð·Ðµ Ð´Ð°Ð½Ð½Ñ‹Ñ…
        DB_CONFIG = {
            'host': 'localhost',
            'port': 5432,
            'user': 'postgres', 
            'password': 'r/Yskqh/ZbZuvjb2b3ahfg==',
            'database': 'postgres'
        }
        
        conn = await asyncpg.connect(**DB_CONFIG)
        try:
            result = await conn.fetchrow(
                "SELECT name FROM enterprises WHERE number = $1",
                enterprise_number
            )
            
            if result and result['name']:
                return result['name']
            else:
                return enterprise_number  # fallback Ð½Ð° Ð½Ð¾Ð¼ÐµÑ€ ÐµÑÐ»Ð¸ Ð½ÐµÑ‚ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ
                
        finally:
            await conn.close()
            
    except Exception as e:
        logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ Ð¿Ñ€ÐµÐ´Ð¿Ñ€Ð¸ÑÑ‚Ð¸Ñ: {e}")
        return enterprise_number or "ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾"

async def check_user_authorization(telegram_id: int) -> bool:
    """ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð°Ð²Ñ‚Ð¾Ñ€Ð¸Ð·Ð¾Ð²Ð°Ð½ Ð»Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ"""
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(
                f"{TELEGRAM_AUTH_SERVICE_URL}/check_auth_status/{telegram_id}",
                timeout=10
            )
            if response.status_code == 200:
                result = response.json()
                return result.get("authorized", False)
    except:
        pass
    return False