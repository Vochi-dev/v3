import logging
import asyncio
import contextlib
from fastapi import FastAPI, Request, Form, HTTPException, status, Body
from fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from fastapi.exceptions import RequestValidationError
from fastapi.logger import logger as fastapi_logger
from starlette.middleware.base import BaseHTTPMiddleware

from app.services.database import (
    get_all_enterprises,
    get_enterprise_by_number,
    add_enterprise,
    update_enterprise,
    delete_enterprise,
)
from app.services.enterprise import send_message_to_bot
from app.services.bot_status import check_bot_status
from app.services.db import get_all_bot_tokens

from telegram import Bot
from telegram.error import TelegramError

from aiogram import Bot as AiogramBot
from aiogram.enums import ParseMode
from aiogram.exceptions import TelegramAPIError
from aiogram.client.default import DefaultBotProperties

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ĞŸĞ¾Ğ´ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ Ğ°Ğ´Ğ¼Ğ¸Ğ½-Ğ¼Ğ°Ñ€ÑˆÑ€ÑƒÑ‚Ñ‹
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
from app.routers import admin           # /admin/*
from app.routers.email_users import router as email_users_router   # /admin/email-users
from app.routers.auth_email import router as auth_email_router     # /verify-email/{token}

# Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ dispatcher Ñ Ğ»Ğ¾Ğ³Ğ¸ĞºĞ¾Ğ¹ /start Ğ¸ e-mail
from app.telegram.dispatcher import setup_dispatcher

# ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸ Asterisk
from app.services.calls import (
    process_start,
    process_dial,
    process_bridge,
    process_hangup
)
import aiosqlite
from app.config import DB_PATH

# --- ĞĞ°ÑÑ‚Ñ€Ğ¾Ğ¹ĞºĞ° Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ ---
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s"
)
logger = logging.getLogger(__name__)

# --- Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ FastAPI Ñ debug=True Ğ´Ğ»Ñ Ñ€Ğ°ÑÑˆĞ¸Ñ€ĞµĞ½Ğ½Ğ¾Ğ³Ğ¾ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ ---
app = FastAPI(debug=True)

# ĞŸĞ¾Ğ²Ñ‹ÑˆĞ°ĞµĞ¼ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ»Ğ¾Ğ³Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ´Ğ»Ñ uvicorn Ğ¸ fastapi
logging.getLogger("uvicorn").setLevel(logging.DEBUG)
logging.getLogger("uvicorn.error").setLevel(logging.DEBUG)
logging.getLogger("uvicorn.access").setLevel(logging.DEBUG)
fastapi_logger.setLevel(logging.DEBUG)

templates = Jinja2Templates(directory="app/templates")
app.mount("/static", StaticFiles(directory="app/static"), name="static")

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€ÑƒĞµĞ¼ Ñ€Ğ¾ÑƒÑ‚ĞµÑ€Ñ‹
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.include_router(admin.router)              # /admin/*
app.include_router(email_users_router)        # /admin/email-users*
app.include_router(auth_email_router)         # /verify-email/{token}

# --- ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ¾ÑˆĞ¸Ğ±Ğ¾Ğº Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ°Ñ†Ğ¸Ğ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² (422) ---
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    fastapi_logger.error(
        f"Validation error for {request.method} {request.url}\nErrors: {exc.errors()}"
    )
    try:
        body = await request.body()
        fastapi_logger.debug(f"Request body: {body.decode('utf-8')}")
    except Exception as e:
        fastapi_logger.debug(f"Could not read request body: {e}")
    return JSONResponse(
        status_code=422,
        content={"detail": exc.errors()}
    )

class LoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        logger.info("Incoming request: %s %s", request.method, request.url)
        try:
            response = await call_next(request)
        except Exception:
            logger.exception("Exception during request processing")
            raise
        logger.info("Response status: %d for %s %s", response.status_code, request.method, request.url)
        return response

app.add_middleware(LoggingMiddleware)

@app.get("/", response_class=HTMLResponse)
async def root(request: Request):
    return RedirectResponse(url="/admin/enterprises")

@app.get("/admin/enterprises", response_class=HTMLResponse)
async def list_enterprises(request: Request):
    logger.info("list_enterprises called")
    enterprises_rows = await get_all_enterprises()
    enterprises = [dict(ent) for ent in enterprises_rows]
    enterprises_sorted = sorted(enterprises, key=lambda e: int(e['number']))

    for ent in enterprises_sorted:
        bot_token = ent.get("bot_token") or ""
        if not bot_token.strip():
            ent["bot_available"] = False
            logger.info(f"Enterprise #{ent['number']} - no bot_token, bot_available set to False")
            continue
        try:
            ent["bot_available"] = await check_bot_status(bot_token)
            logger.info(f"Enterprise #{ent['number']} - bot_available: {ent['bot_available']}")
        except Exception as e:
            logger.error(f"Error checking bot status for #{ent['number']}: {e}")
            ent["bot_available"] = False

    return templates.TemplateResponse(
        "enterprises.html",
        {
            "request": request,
            "enterprises": enterprises_sorted,
            "bots_running": True,
        }
    )

@app.api_route("/admin/enterprises/add", methods=["GET", "POST"], response_class=HTMLResponse)
async def add_enterprise_form(request: Request):
    if request.method == "GET":
        return templates.TemplateResponse(
            "enterprise_form.html",
            {"request": request, "enterprise": {}, "action": "add", "error": None}
        )

    form = await request.form()
    number = form.get("number", "")
    name = form.get("name", "")
    secret = form.get("secret", "")
    bot_token = form.get("bot_token", "")
    chat_id = form.get("chat_id", "")
    ip = form.get("ip", "")
    host = form.get("host", "")
    name2 = form.get("name2", "")

    enterprises = await get_all_enterprises()
    for ent in enterprises:
        if ent['number'] == number:
            error = f"ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ñ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ¾Ğ¼ {number} ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚"
            break
        if ent['name'].strip().lower() == name.strip().lower():
            error = f"ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ñ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ '{name}' ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚"
            break
        existing_name2 = ent['name2'] or ""
        if existing_name2.strip().lower() == name2.strip().lower() and name2.strip():
            error = f"ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ñ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼ Ğ¸Ğ¼ĞµĞ½ĞµĞ¼ '{name2}' ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚"
            break
        if ent['ip'] == ip:
            error = f"ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ñ IP {ip} ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚"
            break
    else:
        error = None

    if error:
        return templates.TemplateResponse(
            "enterprise_form.html",
            {
                "request": request,
                "enterprise": {
                    "number": number,
                    "name": name,
                    "secret": secret,
                    "bot_token": bot_token,
                    "chat_id": chat_id,
                    "ip": ip,
                    "host": host,
                    "name2": name2,
                },
                "action": "add",
                "error": error,
            },
            status_code=status.HTTP_400_BAD_REQUEST,
        )

    await add_enterprise(number, name, bot_token, chat_id, ip, secret, host, name2)
    return RedirectResponse(url="/admin/enterprises", status_code=status.HTTP_303_SEE_OTHER)

@app.get("/admin/enterprises/{number}/edit", response_class=HTMLResponse)
async def edit_enterprise_form(request: Request, number: str):
    enterprise = await get_enterprise_by_number(number)
    if not enterprise:
        raise HTTPException(status_code=404, detail="ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾")
    return templates.TemplateResponse(
        "enterprise_form.html",
        {"request": request, "enterprise": enterprise, "action": "edit", "error": None}
    )

@app.post("/admin/enterprises/{number}/edit", response_class=HTMLResponse)
async def update_enterprise_post(
    request: Request,
    number: str,
    name: str = Form(...),
    secret: str = Form(...),
    bot_token: str = Form(""),
    chat_id: str = Form(""),
    ip: str = Form(...),
    host: str = Form(...),
    name2: str = Form(""),
):
    enterprises = await get_all_enterprises()
    for ent in enterprises:
        if ent['number'] != number:
            if ent['name'].strip().lower() == name.strip().lower():
                error = f"ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ñ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸ĞµĞ¼ '{name}' ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚"
                break
            existing_name2 = ent['name2'] or ""
            if existing_name2.strip().lower() == name2.strip().lower() and name2.strip():
                error = f"ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ñ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ñ‹Ğ¼ Ğ¸Ğ¼ĞµĞ½ĞµĞ¼ '{name2}' ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚"
                break
            if ent['ip'] == ip:
                error = f"ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ñ IP {ip} already exists"
                break
    else:
        error = None

    if error:
        enterprise = {
            "number": number,
            "name": name,
            "secret": secret,
            "bot_token": bot_token,
            "chat_id": chat_id,
            "ip": ip,
            "host": host,
            "name2": name2,
        }
        return templates.TemplateResponse(
            "enterprise_form.html",
            {
                "request": request,
                "enterprise": enterprise,
                "action": "edit",
                "error": error,
            },
            status_code=status.HTTP_400_BAD_REQUEST,
        )

    await update_enterprise(number, name, bot_token, chat_id, ip, secret, host, name2)
    return RedirectResponse(url="/admin/enterprises", status_code=status.HTTP_303_SEE_OTHER)

@app.delete("/admin/enterprises/{number}")
async def delete_enterprise_api(number: str):
    await delete_enterprise(number)
    return {"detail": "ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ ÑƒĞ´Ğ°Ğ»ĞµĞ½Ğ¾"}

@app.post("/admin/enterprises/{number}/send_message")
async def send_message_api(number: str, request: Request):
    data = await request.json()
    message = data.get("message")
    logger.debug(f"send_message_api called for enterprise #{number} with message: {message!r}")

    if not message:
        logger.warning(f"Empty message received for enterprise #{number}")
        raise HTTPException(status_code=400, detail="Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ½Ğµ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ¿ÑƒÑÑ‚Ñ‹Ğ¼")

    enterprise = await get_enterprise_by_number(number)
    logger.debug(f"Enterprise data retrieved for #{number}: {enterprise}")

    if not enterprise:
        logger.error(f"Enterprise #{number} not found in database")
        raise HTTPException(status_code=404, detail="ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾")

    if not isinstance(enterprise, dict):
        enterprise = dict(enterprise)

    bot_token = enterprise.get('bot_token', "")
    chat_id = enterprise.get('chat_id', "")

    if not bot_token.strip():
        logger.error(f"Enterprise #{number} has no bot_token or it is empty")
        raise HTTPException(status_code=400, detail="Ğ£ Ğ¿Ñ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ Ñ‚Ğ¾ĞºĞµĞ½ Ğ±Ğ¾Ñ‚Ğ°")

    if not chat_id.strip():
        logger.error(f"Enterprise #{number} has no chat_id Ğ¸Ğ»Ğ¸ Ğ¾Ğ½Ğ¾ Ğ¿ÑƒÑÑ‚Ğ¾Ğµ")
        raise HTTPException(status_code=400, detail="Ğ£ Ğ¿Ñ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ñ Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ chat_id Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¸")

    try:
        success = await send_message_to_bot(bot_token, chat_id, message)
        if success:
            logger.info(f"Message sent successfully to enterprise #{number}")
        else:
            logger.error(f"send_message_to_bot returned False for enterprise #{number}")
            raise HTTPException(status_code=500, detail="ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ±Ğ¾Ñ‚Ñƒ")
    except Exception as e:
        logger.exception(f"Failed to send message to bot {number}: {e}")
        raise HTTPException(status_code=500, detail="ĞĞµ ÑƒĞ´Ğ°Ğ»Ğ¾ÑÑŒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ")

    return {"detail": "Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾"}

@app.post("/admin/enterprises/{number}/toggle")
async def toggle_enterprise(request: Request, number: str):
    logger.info(f"toggle_enterprise called for #{number}")
    enterprise = await get_enterprise_by_number(number)
    if not enterprise:
        logger.error(f"Enterprise #{number} not found on toggle")
        raise HTTPException(status_code=404, detail="ĞŸÑ€ĞµĞ´Ğ¿Ñ€Ğ¸ÑÑ‚Ğ¸Ğµ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾")

    if not isinstance(enterprise, dict):
        enterprise = dict(enterprise)

    current_active = enterprise.get("active", 0)
    new_status = 0 if current_active else 1
    logger.debug(f"Enterprise #{number} current_active={current_active}, toggling to {new_status}")

    await update_enterprise(
        number,
        enterprise.get("name", ""),
        enterprise.get("bot_token", ""),
        enterprise.get("chat_id", ""),
        enterprise.get("ip", ""),
        enterprise.get("secret", ""),
        enterprise.get("host", ""),
        enterprise.get("name2", ""),
        active=new_status
    )

    bot = Bot(token=enterprise.get("bot_token"))
    text = f"âœ… Ğ¡ĞµÑ€Ğ²Ğ¸Ñ {'Ğ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½' if new_status else 'Ğ´ĞµĞ°ĞºÑ‚Ğ¸Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½'}"
    try:
        await bot.send_message(chat_id=int(enterprise.get("chat_id")), text=text)
    except TelegramError:
        logger.error("Toggle notification failed for %s", number)

    return RedirectResponse(url="/admin/enterprises", status_code=status.HTTP_303_SEE_OTHER)

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Asterisk Webhooks â€” Ğ¿Ñ€ÑĞ¼Ğ°Ñ Ñ€Ğ°ÑÑÑ‹Ğ»ĞºĞ° Ğ±ĞµĞ· reply_to
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async def _get_bot_and_recipients(asterisk_token: str) -> tuple[str, list[int]]:
    async with aiosqlite.connect(DB_PATH) as db:
        db.row_factory = aiosqlite.Row
        cur = await db.execute(
            "SELECT bot_token FROM enterprises WHERE name2 = ?",
            (asterisk_token,)
        )
        ent = await cur.fetchone()
        if not ent:
            raise HTTPException(status_code=404, detail="Unknown enterprise token")
        bot_token = ent["bot_token"]
        cur = await db.execute(
            "SELECT tg_id FROM telegram_users WHERE bot_token = ? AND verified = 1",
            (bot_token,)
        )
        rows = await cur.fetchall()
    return bot_token, [int(r["tg_id"]) for r in rows]

async def _send_to_unit(asterisk_token: str, text: str) -> list[dict]:
    bot_token, tg_ids = await _get_bot_and_recipients(asterisk_token)
    bot = Bot(token=bot_token)
    results = []
    for chat_id in tg_ids:
        try:
            await bot.send_message(chat_id=int(chat_id), text=text, parse_mode="HTML")
            results.append({"chat_id": chat_id, "status": "ok"})
        except Exception as e:
            logger.error(f"Asterisk dispatch to {chat_id} failed: {e}")
            results.append({"chat_id": chat_id, "status": "error", "error": str(e)})
    return results

@app.post("/start")
async def asterisk_start(body: dict = Body(...)):
    caller = body.get("Caller", "")
    text = f"ğŸ›ï¸ Ğ’Ñ…Ğ¾Ğ´ÑÑ‰Ğ¸Ğ¹ Ğ·Ğ²Ğ¾Ğ½Ğ¾Ğº\nğŸ’° {caller}"
    delivered = await _send_to_unit(body.get("Token"), text)
    return JSONResponse({"delivered": delivered})

@app.post("/dial")
async def asterisk_dial(body: dict = Body(...)):
    caller = body.get("Caller", "")
    called = body.get("Called", "")
    text = f"ğŸ›ï¸ Ğ Ğ°Ğ·Ğ³Ğ¾Ğ²Ğ¾Ñ€\nğŸ’° {caller} â¡ï¸ {called}"
    delivered = await _send_to_unit(body.get("Token"), text)
    return JSONResponse({"delivered": delivered})

@app.post("/bridge")
async def asterisk_bridge(body: dict = Body(...)):
    caller = body.get("Caller", "")
    text = f"ğŸ”— Ğ¡ĞµÑÑĞ¸Ñ ÑĞ¾ĞµĞ´Ğ¸Ğ½ĞµĞ½Ğ°\nğŸ’° {caller}"
    delivered = await _send_to_unit(body.get("Token"), text)
    return JSONResponse({"delivered": delivered})

@app.post("/hangup")
async def asterisk_hangup(body: dict = Body(...)):
    duration = body.get("Duration", "")
    caller   = body.get("Caller", "")
    text = f"âŒ Ğ—Ğ°Ğ²ĞµÑ€ÑˆÑ‘Ğ½Ğ½Ñ‹Ğ¹ Ğ·Ğ²Ğ¾Ğ½Ğ¾Ğº\nâŒ› {duration}\nğŸ’° {caller}"
    delivered = await _send_to_unit(body.get("Token"), text)
    return JSONResponse({"delivered": delivered})


async def start_bot(enterprise_number: str, token: str):
    bot = AiogramBot(
        token=token,
        default=DefaultBotProperties(parse_mode=ParseMode.HTML)
    )
    dp = await setup_dispatcher(bot, enterprise_number)
    try:
        logger.info(f"Starting bot for enterprise {enterprise_number}")
        await dp.start_polling(bot)
    finally:
        await bot.session.close()

async def start_all_bots():
    tokens = await get_all_bot_tokens()
    tasks = []
    for enterprise_number, token in tokens.items():
        if not token or not token.strip():
            continue
        tasks.append(asyncio.create_task(start_bot(enterprise_number, token)))
    await asyncio.gather(*tasks)

@app.on_event("startup")
async def on_startup():
    logger.info("Starting all telegram bots in background task...")
    asyncio.create_task(start_all_bots())


@app.on_event("shutdown")
async def shutdown_event():
    logger.info("Shutting down bots gracefully...")
    for task in asyncio.all_tasks():
        task.cancel()
