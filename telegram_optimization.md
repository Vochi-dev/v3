# План оптимизации отправки событий в Telegram

**Дата создания:** 02.12.2025  
**Проблема:** Задержка отправки событий в Telegram составляет 2-6 секунд вместо ожидаемых <1 секунды

---

## Диагностика (выполнено)

### Текущая ситуация
- **Один звонок** генерирует **43+ HTTP запросов** к внутренним сервисам
- **Enrichment** занимает ~2 секунды из-за последовательных запросов
- **Дублирование запросов** - одни и те же данные запрашиваются многократно
- **Последовательная обработка** - события обрабатываются по одному, не параллельно

### Пример задержки (звонок 1764692349.10447)
| Этап | Время |
|------|-------|
| REQUEST пришёл | 16:19:10,851 |
| Enrichment завершён | 16:19:12,818 |
| Telegram отправлен | 16:19:12,975 |
| **Итого задержка** | **~2.1 сек** |

### HTTP запросы на один звонок
```
GET /incoming-transform/{enterprise}     - 3 раза (для start, dial, hangup)
GET /metadata/{enterprise}/line/{trunk}  - 4 раза (дубли!)
GET /metadata/{enterprise}/manager/{ext} - 20+ раз (для каждого extension)
GET /customer-name/{enterprise}/{phone}  - 2 раза
POST /telegram/message                   - для каждого события
```

---

## TODO: Оптимизация

### 1. [x] Кэширование metadata (Приоритет: ВЫСОКИЙ) ✅ DONE 03.12.2025
**Файл:** `app/services/metadata_client.py`

- [x] Добавить in-memory кэш для `line` данных (TTL: 5 минут)
- [x] Добавить in-memory кэш для `manager` данных (TTL: 5 минут)
- [x] Добавить in-memory кэш для `customer-name` (TTL: 1 минута)
- [x] Использовать простой dict с timestamp

**Результат:** Кэширование работает, видны CACHE HIT в логах

### 2. [ ] Убрать дублирующиеся запросы (Приоритет: ВЫСОКИЙ)
**Файл:** `main.py`

- [ ] Enrichment делать ОДИН раз в `_dispatch_to_all`, а не в каждом handler
- [ ] Проверить что `_enriched_data` передаётся и используется во всех handlers
- [ ] Убрать повторные вызовы `metadata_client.enrich_message_data()`

**Ожидаемый эффект:** -30% HTTP запросов

### 3. [x] Параллельные HTTP запросы (Приоритет: СРЕДНИЙ) ✅ DONE 03.12.2025
**Файлы:** `app/services/metadata_client.py`

- [x] Использовать `asyncio.gather()` для параллельных запросов в `enrich_message_data()`
- [ ] Batch запрос для extensions (один запрос вместо 20) - TODO

**Результат:** 
- Line, manager, customer запрашиваются параллельно вместо последовательно
- Shared HTTP client вместо создания нового для каждого запроса

### 4. [ ] Убрать `/incoming-transform` запросы (Приоритет: СРЕДНИЙ)
**Файл:** `main.py`

- [ ] Проверить зачем нужен `/incoming-transform` для каждого события
- [ ] Если для валидации - кэшировать результат на время звонка
- [ ] Если не критично - убрать или сделать опциональным

**Ожидаемый эффект:** -3 HTTP запроса на звонок

### 5. [ ] Оптимизация dial с множеством extensions (Приоритет: СРЕДНИЙ)
**Файл:** `app/services/calls/dial.py`

- [ ] Не запрашивать metadata для каждого extension отдельно
- [ ] Batch endpoint: `GET /metadata/{enterprise}/managers?exts=151,153,154...`
- [ ] Или показывать только первые 3-5 extensions, остальные "и ещё N"

**Ожидаемый эффект:** -15 HTTP запросов для Ring Group

### 6. [ ] Убрать искусственные задержки (Приоритет: НИЗКИЙ)
**Файлы:** `app/services/calls/dial.py`, `app/services/calls/bridge.py`

- [ ] Проверить `asyncio.sleep(0.5)` в dial.py - зачем нужен?
- [ ] Проверить `asyncio.sleep(0.1)` в bridge.py - зачем нужен?
- [ ] Убрать или уменьшить если не критично

**Ожидаемый эффект:** -0.5 сек на событие

### 7. [ ] Очередь событий по UniqueId (Приоритет: НИЗКИЙ)
**Файл:** `main.py`

- [ ] События одного звонка обрабатывать строго последовательно
- [ ] Гарантировать порядок: start → dial → bridge → hangup
- [ ] Предотвратить ситуацию когда hangup приходит раньше dial

**Ожидаемый эффект:** Корректный порядок сообщений в Telegram

---

## Метрики для проверки

### До оптимизации
- [ ] Замерить среднее время от REQUEST до Telegram send
- [ ] Посчитать количество HTTP запросов на звонок
- [ ] Записать примеры с timestamps

### После оптимизации
- [ ] Сравнить время отправки
- [ ] Сравнить количество HTTP запросов
- [ ] Проверить на большом потоке звонков (0351)

---

## Порядок выполнения

1. **День 1:** Пункты 1-2 (кэширование + убрать дубли)
2. **День 2:** Пункты 3-4 (параллельные запросы)
3. **День 3:** Пункты 5-7 (dial оптимизация + очередь)

---

## Риски

- **Кэширование** может показывать устаревшие данные (имя клиента изменилось)
- **Параллельные запросы** могут создать нагрузку на metadata service
- **Убирание задержек** может сломать логику замены сообщений

---

## Откат

При проблемах - откат на коммит `6b2b0c9` от 02.12.2025

