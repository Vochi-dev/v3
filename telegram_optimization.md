# План оптимизации отправки событий в Telegram

**Дата создания:** 02.12.2025  
**Проблема:** Задержка отправки событий в Telegram составляет 2-6 секунд вместо ожидаемых <1 секунды

---

## Диагностика (выполнено)

### Текущая ситуация
- **Один звонок** генерирует **43+ HTTP запросов** к внутренним сервисам
- **Enrichment** занимает ~2 секунды из-за последовательных запросов
- **Дублирование запросов** - одни и те же данные запрашиваются многократно
- **Последовательная обработка** - события обрабатываются по одному, не параллельно

### Пример задержки (звонок 1764692349.10447)
| Этап | Время |
|------|-------|
| REQUEST пришёл | 16:19:10,851 |
| Enrichment завершён | 16:19:12,818 |
| Telegram отправлен | 16:19:12,975 |
| **Итого задержка** | **~2.1 сек** |

### HTTP запросы на один звонок
```
GET /incoming-transform/{enterprise}     - 3 раза (для start, dial, hangup)
GET /metadata/{enterprise}/line/{trunk}  - 4 раза (дубли!)
GET /metadata/{enterprise}/manager/{ext} - 20+ раз (для каждого extension)
GET /customer-name/{enterprise}/{phone}  - 2 раза
POST /telegram/message                   - для каждого события
```

---

## TODO: Оптимизация

### 1. [x] Кэширование metadata (Приоритет: ВЫСОКИЙ) ✅ DONE 03.12.2025
**Файл:** `app/services/metadata_client.py`

- [x] Добавить in-memory кэш для `line` данных (TTL: 5 минут)
- [x] Добавить in-memory кэш для `manager` данных (TTL: 5 минут)
- [x] Добавить in-memory кэш для `customer-name` (TTL: 1 минута)
- [x] Использовать простой dict с timestamp

**Результат:** Кэширование работает, видны CACHE HIT в логах

### 2. [x] Убрать дублирующиеся запросы (Приоритет: ВЫСОКИЙ) ✅ VERIFIED 03.12.2025
**Файл:** `main.py`

- [x] Enrichment делается ОДИН раз в `_dispatch_to_all`
- [x] `_enriched_data` передаётся и используется во всех handlers
- [x] Только fallback в hangup.py (если данных нет) - это OK

**Результат:** Дублей нет, архитектура правильная

### 3. [x] Параллельные HTTP запросы (Приоритет: СРЕДНИЙ) ✅ DONE 03.12.2025
**Файлы:** `app/services/metadata_client.py`

- [x] Использовать `asyncio.gather()` для параллельных запросов в `enrich_message_data()`
- [ ] Batch запрос для extensions (один запрос вместо 20) - TODO

**Результат:** 
- Line, manager, customer запрашиваются параллельно вместо последовательно
- Shared HTTP client вместо создания нового для каждого запроса

### 4. [x] Кэширование `/incoming-transform` (Приоритет: СРЕДНИЙ) ✅ DONE 03.12.2025
**Файл:** `main.py`

- [x] Добавить кэш для incoming-transform (TTL: 5 минут)
- [x] Использовать кэшированные данные вместо HTTP запроса каждый раз

**Результат:** -3 HTTP запроса на звонок (один запрос на enterprise вместо каждого события)

### 5. [x] Оптимизация dial с множеством extensions (Приоритет: СРЕДНИЙ) ✅ DONE 03.12.2025
**Файл:** `app/services/calls/dial.py`

- [x] Убраны HTTP запросы для каждого extension (было 15-20 запросов!)
- [x] Показываем только номера extensions без имён менеджеров
- [x] Имена менеджеров редко настроены - экономия не влияет на UX

**Результат:** -15-20 HTTP запросов для Ring Group

### 6. [x] Уменьшить искусственные задержки (Приоритет: НИЗКИЙ) ✅ DONE 03.12.2025
**Файлы:** `app/services/calls/dial.py`

- [x] Уменьшить `asyncio.sleep(0.5)` до `0.1` в dial.py (при workers=1 race condition маловероятен)
- [ ] `asyncio.sleep(0.1)` в bridge.py - оставлен (race condition fix)

**Результат:** -0.4 сек на событие dial

### 7. [ ] Очередь событий по UniqueId (Приоритет: НИЗКИЙ)
**Файл:** `main.py`

- [ ] События одного звонка обрабатывать строго последовательно
- [ ] Гарантировать порядок: start → dial → bridge → hangup
- [ ] Предотвратить ситуацию когда hangup приходит раньше dial

**Ожидаемый эффект:** Корректный порядок сообщений в Telegram

---

## Метрики для проверки

### До оптимизации
- [ ] Замерить среднее время от REQUEST до Telegram send
- [ ] Посчитать количество HTTP запросов на звонок
- [ ] Записать примеры с timestamps

### После оптимизации
- [ ] Сравнить время отправки
- [ ] Сравнить количество HTTP запросов
- [ ] Проверить на большом потоке звонков (0351)

---

## Порядок выполнения

1. **День 1:** Пункты 1-2 (кэширование + убрать дубли)
2. **День 2:** Пункты 3-4 (параллельные запросы)
3. **День 3:** Пункты 5-7 (dial оптимизация + очередь)

---

## Риски

- **Кэширование** может показывать устаревшие данные (имя клиента изменилось)
- **Параллельные запросы** могут создать нагрузку на metadata service
- **Убирание задержек** может сломать логику замены сообщений

---

## Откат

При проблемах - откат на коммит `6b2b0c9` от 02.12.2025

