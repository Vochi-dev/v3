#!/usr/bin/env python3
"""
–£–º–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –∫—ç—à–∞ —Å –≥–∏–±—Ä–∏–¥–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π

–ê–≤—Ç–æ—Ä: Assistant  
–î–∞—Ç–∞: 2025-09-14
"""

import asyncio
import json
import logging
from typing import Set, Dict, Optional
from datetime import datetime, timedelta

from .event_cache import EventCache
from .event_filter import Event


class SmartCacheManager:
    """
    –£–º–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä –∫—ç—à–∞ —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è–º–∏:
    
    1. Reactive - —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é (–¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–≤–æ–Ω–∫–æ–≤)
    2. Proactive - –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è (–¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –∑–≤–æ–Ω–∫–æ–≤) 
    3. Smart triggers - —Ç—Ä–∏–≥–≥–µ—Ä—ã –¥–ª—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
    """
    
    def __init__(self, event_cache: Optional[EventCache] = None):
        self.event_cache = event_cache or EventCache()
        self.logger = logging.getLogger(__name__)
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏
        self.FILTER_DELAY = 2  # –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–µ–π –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–≤–æ–Ω–∫–æ–≤ (—Å–µ–∫)
        self.BATCH_SIZE = 10   # –†–∞–∑–º–µ—Ä batch –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        
        # –°–æ—Å—Ç–æ—è–Ω–∏–µ
        self.pending_calls: Set[str] = set()  # –ó–≤–æ–Ω–∫–∏ –æ–∂–∏–¥–∞—é—â–∏–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
        self.processing_calls: Set[str] = set()  # –ó–≤–æ–Ω–∫–∏ –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
        self.background_task: Optional[asyncio.Task] = None
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # –û–°–ù–û–í–ù–û–ô API
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async def handle_new_event(self, event: Event) -> None:
        """
        –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–æ–≤–æ–µ —Å–æ–±—ã—Ç–∏–µ AMI
        
        –°—Ç—Ä–∞—Ç–µ–≥–∏—è:
        1. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–±—ã—Ç–∏–µ –≤ –∫—ç—à
        2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω—É–∂–Ω–∞ –ª–∏ –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è
        3. –ü–ª–∞–Ω–∏—Ä—É–µ–º —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é –∏–ª–∏ —Å—Ç–∞–≤–∏–º –≤ –æ—á–µ—Ä–µ–¥—å
        """
        call_id = event.uniqueid
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ–±—ã—Ç–∏–µ
        self.event_cache.add_event(event)
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –æ–±—Ä–∞–±–æ—Ç–∫–∏
        strategy = self._determine_processing_strategy(event, call_id)
        
        if strategy == "immediate":
            # –ù–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è (–¥–ª—è hangup —Å–æ–±—ã—Ç–∏–π)
            await self._process_call_immediately(call_id)
            
        elif strategy == "delayed":
            # –û—Ç–ª–æ–∂–µ–Ω–Ω–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è (–¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–≤–æ–Ω–∫–æ–≤)
            self._schedule_delayed_processing(call_id)
            
        elif strategy == "background":
            # –§–æ–Ω–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ (–¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –∑–≤–æ–Ω–∫–æ–≤)
            self._add_to_background_queue(call_id)
    
    async def get_filtered_events(self, call_id: str, integration: str) -> list:
        """
        –ü–æ–ª—É—á–∞–µ—Ç –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è —Å —É–º–Ω–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–µ–π
        """
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ –≤ –∫—ç—à–µ
        cached_events = self.event_cache.get_filtered_events(call_id, integration)
        if cached_events:
            return cached_events
        
        # –ï—Å–ª–∏ –Ω–µ—Ç –≤ –∫—ç—à–µ - –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –æ–±—Ä–∞–±–æ—Ç–∫–∏
        if call_id in self.processing_calls:
            # –ó–≤–æ–Ω–æ–∫ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è - –∂–¥–µ–º
            await self._wait_for_processing(call_id)
            return self.event_cache.get_filtered_events(call_id, integration)
        
        # –ï—Å–ª–∏ –∑–≤–æ–Ω–æ–∫ –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è - –∑–∞–ø—É—Å–∫–∞–µ–º –Ω–µ–º–µ–¥–ª–µ–Ω–Ω—É—é —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é
        await self._process_call_immediately(call_id)
        return self.event_cache.get_filtered_events(call_id, integration)
    
    async def start_background_processing(self) -> None:
        """
        –ó–∞–ø—É—Å–∫–∞–µ—Ç —Ñ–æ–Ω–æ–≤—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—á–µ—Ä–µ–¥–∏
        """
        if self.background_task and not self.background_task.done():
            return
        
        self.background_task = asyncio.create_task(self._background_processor())
        self.logger.info("üöÄ –ó–∞–ø—É—â–µ–Ω–∞ —Ñ–æ–Ω–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∫—ç—à–∞")
    
    async def stop_background_processing(self) -> None:
        """
        –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ñ–æ–Ω–æ–≤—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É
        """
        if self.background_task:
            self.background_task.cancel()
            try:
                await self.background_task
            except asyncio.CancelledError:
                pass
        
        self.logger.info("‚èπÔ∏è –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞ —Ñ–æ–Ω–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –∫—ç—à–∞")
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # –°–¢–†–ê–¢–ï–ì–ò–ò –û–ë–†–ê–ë–û–¢–ö–ò
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    def _determine_processing_strategy(self, event: Event, call_id: str) -> str:
        """
        –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –æ–±—Ä–∞–±–æ—Ç–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–∏–ø–∞ —Å–æ–±—ã—Ç–∏—è
        """
        # –ù–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –∑–∞–≤–µ—Ä—à–∞—é—â–∏—Ö —Å–æ–±—ã—Ç–∏–π
        if event.event == 'hangup':
            return "immediate"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∑–≤–æ–Ω–∫–∞
        metadata = self.event_cache.get_call_metadata(call_id)
        if metadata:
            complexity = metadata.get('complexity', 'UNKNOWN')
            
            # –°–ª–æ–∂–Ω—ã–µ –∑–≤–æ–Ω–∫–∏ - –≤ —Ñ–æ–Ω–æ–≤—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É
            if complexity in ['FOLLOWME', 'MULTIPLE_TRANSFER']:
                return "background"
        
        # –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö - –æ—Ç–ª–æ–∂–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
        return "delayed"
    
    async def _process_call_immediately(self, call_id: str) -> None:
        """
        –ù–µ–º–µ–¥–ª–µ–Ω–Ω–∞—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è –∑–≤–æ–Ω–∫–∞
        """
        if call_id in self.processing_calls:
            return
        
        self.processing_calls.add(call_id)
        try:
            # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –≤—ã—á–∏—Å–ª—è–µ–º —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—é –¥–ª—è –≤—Å–µ—Ö –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–π
            for integration in ['bitrix24', 'telegram', 'general']:
                self.event_cache.get_filtered_events(call_id, integration)
            
            self.logger.debug(f"‚ö° –ù–µ–º–µ–¥–ª–µ–Ω–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω –∑–≤–æ–Ω–æ–∫ {call_id}")
            
        finally:
            self.processing_calls.discard(call_id)
            self.pending_calls.discard(call_id)
    
    def _schedule_delayed_processing(self, call_id: str) -> None:
        """
        –ü–ª–∞–Ω–∏—Ä—É–µ—Ç –æ—Ç–ª–æ–∂–µ–Ω–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –∑–≤–æ–Ω–∫–∞
        """
        self.pending_calls.add(call_id)
        
        # –°–æ–∑–¥–∞–µ–º –∑–∞–¥–∞—á—É —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
        async def delayed_process():
            await asyncio.sleep(self.FILTER_DELAY)
            if call_id in self.pending_calls:
                await self._process_call_immediately(call_id)
        
        asyncio.create_task(delayed_process())
    
    def _add_to_background_queue(self, call_id: str) -> None:
        """
        –î–æ–±–∞–≤–ª—è–µ—Ç –∑–≤–æ–Ω–æ–∫ –≤ –æ—á–µ—Ä–µ–¥—å —Ñ–æ–Ω–æ–≤–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
        """
        self.pending_calls.add(call_id)
    
    async def _wait_for_processing(self, call_id: str, max_wait: float = 5.0) -> None:
        """
        –ñ–¥–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–≤–æ–Ω–∫–∞
        """
        start_time = asyncio.get_event_loop().time()
        
        while call_id in self.processing_calls:
            if asyncio.get_event_loop().time() - start_time > max_wait:
                self.logger.warning(f"‚è∞ –¢–∞–π–º–∞—É—Ç –æ–∂–∏–¥–∞–Ω–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ {call_id}")
                break
            
            await asyncio.sleep(0.1)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # –§–û–ù–û–í–ê–Ø –û–ë–†–ê–ë–û–¢–ö–ê
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    async def _background_processor(self) -> None:
        """
        –§–æ–Ω–æ–≤—ã–π –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –æ—á–µ—Ä–µ–¥–∏ –∑–≤–æ–Ω–∫–æ–≤
        """
        while True:
            try:
                # –ü–æ–ª—É—á–∞–µ–º batch –∑–≤–æ–Ω–∫–æ–≤ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
                calls_to_process = list(self.pending_calls)[:self.BATCH_SIZE]
                
                if calls_to_process:
                    await self._process_batch(calls_to_process)
                
                # –ñ–¥–µ–º –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –∏—Ç–µ—Ä–∞—Ü–∏–µ–π
                await asyncio.sleep(1)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–º –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–µ: {e}")
                await asyncio.sleep(5)  # –ü–∞—É–∑–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ
    
    async def _process_batch(self, call_ids: list) -> None:
        """
        –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç batch –∑–≤–æ–Ω–∫–æ–≤
        """
        for call_id in call_ids:
            if call_id not in self.pending_calls:
                continue
            
            try:
                await self._process_call_immediately(call_id)
                
            except Exception as e:
                self.logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ {call_id}: {e}")
        
        self.logger.debug(f"üì¶ –û–±—Ä–∞–±–æ—Ç–∞–Ω batch –∏–∑ {len(call_ids)} –∑–≤–æ–Ω–∫–æ–≤")
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # –ú–û–ù–ò–¢–û–†–ò–ù–ì –ò –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    def get_processing_stats(self) -> Dict:
        """
        –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –æ–±—Ä–∞–±–æ—Ç–∫–∏
        """
        return {
            'pending_calls': len(self.pending_calls),
            'processing_calls': len(self.processing_calls),
            'background_task_running': self.background_task and not self.background_task.done(),
            'cache_stats': self.event_cache.get_cache_stats()
        }
    
    async def health_check(self) -> Dict:
        """
        –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è —Å–∏—Å—Ç–µ–º—ã
        """
        stats = self.get_processing_stats()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ—Ç –ª–∏ –∑–∞—Å—Ç—Ä—è–≤—à–∏—Ö –∑–≤–æ–Ω–∫–æ–≤
        stuck_calls = len(self.processing_calls) > 0
        queue_overload = len(self.pending_calls) > 100
        
        return {
            'status': 'healthy' if not (stuck_calls or queue_overload) else 'warning',
            'issues': {
                'stuck_calls': stuck_calls,
                'queue_overload': queue_overload
            },
            'stats': stats
        }
