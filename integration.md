# Система интеграций для Asterisk Webhook

## Концепция: отдельные микросервисы по CRM

- Каждая интеграция — отдельный сервис со своим UI, API, логикой и БД‑доступом.
- Начинаем с существующего `retailcrm.py` (порт 8019): развиваем до полноценного мультиюнитного сервиса.
- Никакого общего агрегирующего сервиса для интеграций не требуется.

## Архитектура (микросервис на каждую CRM)

- main.py:8000 — основной API и служебные сервисы (без логики интеграций)
- enterprise_admin_service.py:8004 — админка юнита (кнопка "Интеграции" открывает UI конкретной CRM)
- retailcrm.py:8019 — сервис RetailCRM: UI администрирования, приём событий, вызовы API RetailCRM, логи
- dial.py/bridge.py/hangup.py/download.py — отправляют события в активные CRM‑сервисы асинхронно

## Nginx маршрутизация (внутренняя)

```nginx
# UI и API RetailCRM
location /retailcrm-admin/ {
    proxy_pass http://127.0.0.1:8019/retailcrm-admin/;
}
location /retailcrm/api/ {
    proxy_pass http://127.0.0.1:8019/api/;
}
```

- В UI предприятия: карточка RetailCRM ведёт в новую вкладку на `/retailcrm-admin/`.
- Все внутренние вызовы — только через nginx к 127.0.0.1, без внешнего домена.

## Данные и конфигурации

- Конфиг интеграции хранится в `enterprises.integrations_config` (JSONB) под ключом `retailcrm`.
- Логи интеграций в таблице `integration_logs` (общая для всех интеграций).

Пример `integrations_config` для одного юнита:
```json
{
  "retailcrm": {
    "enabled": true,
    "api_url": "https://example.retailcrm.ru",
    "api_key": "<secret>",
    "client_id": "vochi-asterisk",
    "user_mappings": {"151": 16, "152": 18}
  }
}
```

## Роли и ответственность retailcrm.py (8019)

- UI администрирования (`/retailcrm-admin/`):
  - Формы: домен, API‑ключ, флаги отправки событий, сопоставления сотрудников, тест подключения
  - Авторизация админов предприятия, сохранение в `integrations_config`
- API конфигураций (`/api/config/...`): загрузка/сохранение, валидация, тест подключения
- Приём событий (`/api/events`): `dial`, `bridge`, `hangup` и поток `download` (без карточки)
  - Неблокирующая обработка: ответ Asterisk мгновенно, CRM вызовы в фоне
  - Ретраи/таймауты/идемпотентность по `call_unique_id`
- Smart Redirect (`/api/smart-redirect`):
  - Поиск ответственного в RetailCRM и возврат внутреннего номера
  - Вызов `asterisk.py` (SSH CLI) для `channel redirect` — асинхронно
- Логирование (`integration_logs`): статус, ошибка, пэйлоады запрос/ответ
- Кэш конфигов в памяти с TTL и инвалидацией при сохранении
- Пул `asyncpg`, лимиты конкурентности, rate‑limit per enterprise

## Взаимодействие с сервисами звонков

- `dial.py`, `bridge.py`, `hangup.py`, `download.py`:
  - Определяют по `enterprise_number` активные интеграции (из БД/кэша)
  - Асинхронно шлют события во все включённые CRM‑сервисы
  - Не ждут завершения внешних HTTP при ответе Asterisk

Пример внутренних вызовов (логика):
- `POST /retailcrm/api/events` с телом: `{ enterprise_number, event_type, payload }`
- `POST /retailcrm/api/smart-redirect` для входящего звонка при включённой функции

## Безопасность

- Доступ к UI — только авторизованным администраторам предприятия
- API‑ключи не отображать полностью в UI; хранение в БД возможно в зашифрованном виде
- Внутренние HTTP — через nginx к 127.0.0.1, без внешних обходов

## Наблюдаемость

- `/health`, `/stats` в каждом CRM‑сервисе
- Диагностические страницы: последние успехи/ошибки

## План работ (RetailCRM → мультиюнит)

1) Бэкенд retailcrm.py
- [x] Ввести пространства маршрутов: `/retailcrm-admin/` (UI), `/api/...` (REST)
- [x] Реализовать CRUD конфигов по `enterprise_number` (JSONB + валидация)
- [x] Метрики `/health`, `/stats`
- [ ] Кэш конфигов, инвалидация при сохранении, TTL
- [ ] Эндпоинт `/api/events` (dial/bridge/hangup/download): очередь/фоновые задачи
- [ ] Эндпоинт `/api/smart-redirect` с вызовом RetailCRM и интеграцией с `asterisk.py`
- [ ] Логи в `integration_logs` (успех/ошибка, краткое сообщение, пэйлоады)

2) UI retailcrm-admin
- [ ] Страницы: Подключение, Настройки, Логи, Тест подключения
- [ ] Авторизация админа предприятия, безопасное отображение секретов
- [ ] Сохранение настроек → запись в `integrations_config`

3) Интеграция с сервисами звонков
- [ ] В серверах событий настроить асинхронные POST на `/retailcrm/api/events`
- [ ] Не блокировать ответ Asterisk (fire‑and‑forget / фоновые tasks)

4) Надёжность
- [ ] Ретраи + экспоненциальный бэкофф
- [ ] Идемпотентность на `call_unique_id`
- [ ] Rate‑limit и семафоры на внешние вызовы per enterprise

5) Документация и тесты
- [ ] Документация API `/api/...`
- [ ] Нагрузочные тесты (пиковые звонки)
- [ ] Набор unit/интеграционных тестов

## To-Do Tracker (детализация по кэшированию и неблокирующей обработке)

- [ ] Кэш "матрицы включённости" в call‑сервисах (dial/bridge/hangup/download)
  - [ ] Структура: `enterprise_number -> {retailcrm: bool, amocrm: bool, ...}`
  - [ ] Периодический рефреш каждые 180–300 сек (джиттер 10–20%)
  - [ ] TTL на запись 60–120 сек (страховка)
  - [ ] Принудительная инвалидация по `LISTEN/NOTIFY` (payload: `enterprise_number`, `integration_type`)
  - [ ] Anti‑stampede (single‑flight) при промахах кэша
  - [ ] Метрики hit/miss, время загрузки из БД

- [ ] Кэш полных конфигов в `retailcrm.py`
  - [ ] Структура: `enterprise_number -> {api_url, api_key, enabled, опции, маппинги, ...}`
  - [ ] Ленивый прогрев по первому запросу + фоновый фулл‑refresh каждые 180–300 сек
  - [ ] Принудительная инвалидация по `LISTEN/NOTIFY` при изменении настроек
  - [ ] TTL 60–120 сек (страховка), атомарный swap кэша, чтения без блокировок
  - [ ] Ограничение конкурентности при загрузке / внешних вызовах (семафоры per enterprise)
  - [ ] Метрики hit/miss, глубина очереди фоновых задач, error_rate к CRM

- [ ] Неблокирующая обработка событий в call‑сервисах
  - [ ] Моментальный ответ 200 удалённому хосту после чтения кэша
  - [ ] Отправки в CRM строго в фоне (`asyncio.create_task()`/очередь)
  - [ ] Жёсткие таймауты 2–3 сек, ретраи 2–3, экспоненциальный бэкофф
  - [ ] Circuit breaker на юнит/CRM при повторных ошибках (временная пауза)

- [ ] Согласованность между инстансами
  - [ ] Подписка всех сервисов на `LISTEN` соответствующих каналов
  - [ ] Отправка `NOTIFY` после успешной транзакции сохранения настроек
  - [ ] Логи количества инвалидаций, обработанных каждым сервисом

- [ ] Безопасность
  - [ ] Маскирование/не логировать секреты; хранить только в ОЗУ при кэшировании
  - [ ] Доступ к UI только для админов предприятия
  - [ ] Внутренние HTTP через nginx к 127.0.0.1

- [ ] Наблюдаемость
  - [ ] `/health`, `/stats` в `retailcrm.py` и в call‑сервисах
  - [ ] Диагностические страницы: последние успешные/ошибочные попытки
  - [ ] Алерты на падение hit_ratio и рост ошибок к CRM

- [ ] Оптимизации (по согласованию)
  - [ ] (Опционально) GIN‑индекс по `enterprises.integrations_config` для сложных JSONB фильтров
  - [ ] (Опционально) Stale‑while‑revalidate в CRM‑сервисе

## Итоги

- Переходим на архитектуру: один микросервис на каждую CRM.
- `retailcrm.py` (8019) становится эталонным мультиюнитным сервисом с UI и полным циклом интеграции.
- Кэширование — по месту: матрица включённости в call‑сервисах, полный конфиг в CRM‑сервисе.
- Общий агрегирующий сервис не нужен; масштабирование — добавлением новых CRM‑сервисов.