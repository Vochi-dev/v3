# Система интеграций для Asterisk Webhook

## Концепция: отдельные микросервисы по CRM

- Каждая интеграция — отдельный сервис со своим UI, API, логикой и БД‑доступом.
- Начинаем с существующего `retailcrm.py` (порт 8019): развиваем до полноценного мультиюнитного сервиса.
- Никакого общего агрегирующего сервиса для интеграций не требуется.

## Архитектура (микросервис на каждую CRM)

- main.py:8000 — основной API и служебные сервисы (без логики интеграций)
- enterprise_admin_service.py:8004 — админка юнита (кнопка "Интеграции" открывает UI конкретной CRM)
- retailcrm.py:8019 — сервис RetailCRM: UI администрирования, приём событий, вызовы API RetailCRM, логи
- dial.py/bridge.py/hangup.py/download.py — отправляют события в активные CRM‑сервисы асинхронно

## Nginx маршрутизация (внутренняя)

```nginx
# UI и API RetailCRM
location /retailcrm-admin/ {
    proxy_pass http://127.0.0.1:8019/retailcrm-admin/;
}
location /retailcrm/api/ {
    proxy_pass http://127.0.0.1:8019/api/;
}
```

- В UI предприятия: карточка RetailCRM ведёт в новую вкладку на `/retailcrm-admin/`.
- Все внутренние вызовы — только через nginx к 127.0.0.1, без внешнего домена.

## Данные и конфигурации

- Конфиг интеграции хранится в `enterprises.integrations_config` (JSONB) под ключом `retailcrm`.
- Логи интеграций в таблице `integration_logs` (общая для всех интеграций).

Пример `integrations_config` для одного юнита:
```json
{
  "retailcrm": {
    "enabled": true,
    "api_url": "https://example.retailcrm.ru",
    "api_key": "<secret>",
    "client_id": "vochi-asterisk",
    "user_mappings": {"151": 16, "152": 18}
  }
}
```

## Роли и ответственность retailcrm.py (8019)

- UI администрирования (`/retailcrm-admin/`):
  - Формы: домен, API‑ключ, флаги отправки событий, сопоставления сотрудников, тест подключения
  - Авторизация админов предприятия, сохранение в `integrations_config`
- API конфигураций (`/api/config/...`): загрузка/сохранение, валидация, тест подключения
- Приём событий (`/api/events`): `dial`, `bridge`, `hangup` и поток `download` (без карточки)
  - Неблокирующая обработка: ответ Asterisk мгновенно, CRM вызовы в фоне
  - Ретраи/таймауты/идемпотентность по `call_unique_id`
- Smart Redirect (`/api/smart-redirect`):
  - Поиск ответственного в RetailCRM и возврат внутреннего номера
  - Вызов `asterisk.py` (SSH CLI) для `channel redirect` — асинхронно
- Логирование (`integration_logs`): статус, ошибка, пэйлоады запрос/ответ
- Кэш конфигов в памяти с TTL и инвалидацией при сохранении
- Пул `asyncpg`, лимиты конкурентности, rate‑limit per enterprise

## Взаимодействие с сервисами звонков

- `dial.py`, `bridge.py`, `hangup.py`, `download.py`:
  - Определяют по `enterprise_number` активные интеграции (из БД/кэша)
  - Асинхронно шлют события во все включённые CRM‑сервисы
  - Не ждут завершения внешних HTTP при ответе Asterisk

Пример внутренних вызовов (логика):
- `POST /retailcrm/api/events` с телом: `{ enterprise_number, event_type, payload }`
- `POST /retailcrm/api/smart-redirect` для входящего звонка при включённой функции

## Безопасность

- Доступ к UI — только авторизованным администраторам предприятия
- API‑ключи не отображать полностью в UI; хранение в БД возможно в зашифрованном виде
- Внутренние HTTP — через nginx к 127.0.0.1, без внешних обходов

## Наблюдаемость

- `/health`, `/stats` в каждом CRM‑сервисе
- Диагностические страницы: последние успехи/ошибки

## План работ (RetailCRM → мультиюнит)

1) Бэкенд retailcrm.py
- [x] Ввести пространства маршрутов: `/retailcrm-admin/` (UI), `/api/...` (REST)
- [x] Реализовать CRUD конфигов по `enterprise_number` (JSONB + валидация)
- [x] Метрики `/health`, `/stats`
- [x] Кэш конфигов, инвалидация при сохранении, TTL
- [x] Эндпоинты управления кэшем: `/api/config-cache/refresh/{enterprise_number}`, `/api/config-cache/refresh-all`, `/api/config-cache/active-enterprises`
- [ ] Эндпоинт `/api/events` (dial/bridge/hangup/download): очередь/фоновые задачи
- [ ] Эндпоинт `/api/smart-redirect` с вызовом RetailCRM и интеграцией с `asterisk.py`
- [ ] Логи в `integration_logs` (успех/ошибка, краткое сообщение, пэйлоады)

2) UI retailcrm-admin
- [ ] Страницы: Подключение, Настройки, Логи, Тест подключения
- [ ] Авторизация админа предприятия, безопасное отображение секретов
- [ ] Сохранение настроек → запись в `integrations_config`

3) Интеграция с сервисами звонков
- [ ] В серверах событий настроить асинхронные POST на `/retailcrm/api/events`
- [ ] Не блокировать ответ Asterisk (fire‑and‑forget / фоновые tasks)

4) Надёжность
- [ ] Ретраи + экспоненциальный бэкофф
- [ ] Идемпотентность на `call_unique_id`
- [ ] Rate‑limit и семафоры на внешние вызовы per enterprise

5) Документация и тесты
- [ ] Документация API `/api/...`
- [ ] Нагрузочные тесты (пиковые звонки)
- [ ] Набор unit/интеграционных тестов

## To-Do Tracker (детализация по кэшированию и неблокирующей обработке)

- [ ] Кэш "матрицы включённости" в call‑сервисах (dial/bridge/hangup/download)
  - [ ] Структура: `enterprise_number -> {retailcrm: bool, amocrm: bool, ...}`
  - [ ] Периодический рефреш каждые 180–300 сек (джиттер 10–20%)
  - [ ] TTL на запись 60–120 сек (страховка)
  - [ ] Принудительная инвалидация по `LISTEN/NOTIFY` (payload: `enterprise_number`, `integration_type`)
  - [ ] Anti‑stampede (single‑flight) при промахах кэша
  - [ ] Метрики hit/miss, время загрузки из БД

- [x] Кэш полных конфигов в `retailcrm.py`
  - [x] Структура: `enterprise_number -> {api_url, api_key, enabled, опции, маппинги, ...}`
  - [x] Ленивый прогрев по первому запросу + фоновый фулл‑refresh каждые 180–300 сек
  - [ ] Принудительная инвалидация по `LISTEN/NOTIFY` при изменении настроек
  - [x] TTL 60–120 сек (страховка), атомарный swap кэша, чтения без блокировок
  - [ ] Ограничение конкурентности при загрузке / внешних вызовах (семафоры per enterprise)
  - [x] Метрики hit/miss, размер кэша, expiring
  - [x] Эндпоинты `/api/config-cache/*` и `/api/active-enterprises`

- [ ] Неблокирующая обработка событий в call‑сервисах
  - [ ] Моментальный ответ 200 удалённому хосту после чтения кэша
  - [ ] Отправки в CRM строго в фоне (`asyncio.create_task()`/очередь)
  - [ ] Жёсткие таймауты 2–3 сек, ретраи 2–3, экспоненциальный бэкофф
  - [ ] Circuit breaker на юнит/CRM при повторных ошибках (временная пауза)

- [ ] Согласованность между инстансами
  - [ ] Подписка всех сервисов на `LISTEN` соответствующих каналов
  - [ ] Отправка `NOTIFY` после успешной транзакции сохранения настроек
  - [ ] Логи количества инвалидаций, обработанных каждым сервисом

- [ ] Безопасность
  - [ ] Маскирование/не логировать секреты; хранить только в ОЗУ при кэшировании
  - [ ] Доступ к UI только для админов предприятия
  - [ ] Внутренние HTTP через nginx к 127.0.0.1

- [ ] Наблюдаемость
  - [ ] `/health`, `/stats` в `retailcrm.py` и в call‑сервисах
  - [ ] Диагностические страницы: последние успешные/ошибочные попытки
  - [ ] Алерты на падение hit_ratio и рост ошибок к CRM

- [ ] Оптимизации (по согласованию)
  - [ ] (Опционально) GIN‑индекс по `enterprises.integrations_config` для сложных JSONB фильтров
  - [ ] (Опционально) Stale‑while‑revalidate в CRM‑сервисе

## Итоги

- Переходим на архитектуру: один микросервис на каждую CRM.
- `retailcrm.py` (8019) становится эталонным мультиюнитным сервисом с UI и полным циклом интеграции.
- Кэширование — по месту: матрица включённости в call‑сервисах, полный конфиг в CRM‑сервисе.
- Общий агрегирующий сервис не нужен; масштабирование — добавлением новых CRM‑сервисов.

---

## Фактический статус (оперативно)

- UI `retailcrm-admin` работает: страница открывается, заголовок формируется из `enterprises.name`, подключён favicon.
- Форма отправляет запросы на относительные пути под тем же префиксом:
  - `PUT /retailcrm-admin/api/config/{enterprise_number}` — сохранение конфига в `enterprises.integrations_config`.
  - `POST /retailcrm-admin/api/register/{enterprise_number}` — регистрация модуля "Vochi‑CRM" в RetailCRM через `/integration-modules/{code}/edit`.
- Логирование приведено к фактической схеме `integration_logs` (общая таблица):
  - Поля: `enterprise_number`, `integration_type`, `event_type`, `request_data`, `response_data`, `status` (success|error), `error_message`, `created_at`.
  - Пишется событие `event_type=register_module` при каждой попытке регистрации.
- Кэш: реализован кэш конфигов с TTL и фоновым full‑refresh. Исправлена ошибка чтения JSONB (возврат значения без принудительного `dict(...)`).

### Troubleshooting: кнопка «Сохранить и зарегистрировать» даёт 400/422

Симптомы:
- В браузере при POST `/retailcrm-admin/api/register/{enterprise}` отображается ошибка: 400 или 422.
- В `logs/retailcrm.log` встречаются записи:
  - `Input value "integrationModule" contains a non-scalar value` — отправлялся объект вместо JSON‑строки в поле `integrationModule`.
  - `logo: Logo image must be svg` — логотип не в SVG.
  - `baseUrl: This value should not be blank` — отсутствует `baseUrl`.
- Либо 422 от самого сервиса: `JSON decode error` (тело запроса не распарсилось).

Причины:
- Одновременно работали две версии процесса на 8019. Старая версия отвечала с устаревшим payload (JPG‑логотип, без `baseUrl`, с `actions`).
- На стороне UI/бэкенда могла попасться ситуация с пустым/некорректным JSON‑телом (422) — сервер не доходил до вызова RetailCRM.

Как проверить быстро:
- Убедиться, что один процесс слушает 8019: `ss -ltnp '( sport = :8019 )'`.
- Снять хвост `logs/retailcrm.log` и проверить последнюю попытку регистрации: статус 200/201 означает, что payload корректен (SVG + `baseUrl`, без `actions`, `integrationModule` — JSON‑строка).

Исправления, применённые в сервисе:
- Payload регистрации приведён к требованиям RetailCRM: SVG‑логотип, обязательный `baseUrl`, поле `actions` удалено, `integrationModule` передаётся как JSON‑строка внутри form‑data.
- Эндпоинт админки принимает как JSON, так и form‑data; защищён от 422 при пустом/битом теле.

Чек‑лист восстановления:
1) Перезапустить сервисы `./all.sh restart` и убедиться, что на 8019 один процесс.
2) Открыть `/retailcrm-admin/?enterprise_number=XXXX` и нажать «Сохранить и зарегистрировать».
3) Проверить:
   - `enterprises.integrations_config->retailcrm` обновился (домен, ключ, enabled).
   - В `integration_logs` появилась запись `event_type=register_module` со статусом и ответом RetailCRM.
   - В `logs/retailcrm.log` последняя попытка даёт 200/201.

---

## JWT авторизация для кнопки "Перейти в личный кабинет" ✅

### Реализованное решение
При регистрации модуля интеграции генерируется JWT токен, который добавляется в `accountUrl`. Это позволяет пользователям RetailCRM переходить в нашу админку без ввода логина/пароля.

**Компоненты:**
- `generate_retailcrm_access_token()` - генерирует JWT токен с TTL=1 год
- `verify_retailcrm_access_token()` - проверяет валидность токена
- `AuthMiddleware` - обновлён для поддержки JWT авторизации
- В `accountUrl` автоматически добавляется параметр `token=JWT`

**Пример accountUrl:**
```
https://bot.vochi.by/retailcrm-admin/?enterprise_number=0367&token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

**Проверка работы:**
✅ JWT токен генерируется при регистрации модуля
✅ Токен корректно добавляется в accountUrl  
✅ Авторизация по токену работает (middleware проверяет JWT)
✅ Безопасность: токен привязан к конкретному предприятию

Что подтверждено сейчас по среде:

- В БД у юнита `0367` в `integrations_config->retailcrm` всё ещё старый тестовый конфиг (`test.com/test123`) — это значит, что клик "Сохранить и зарегистрировать" не дошёл до актуальных эндпоинтов сохранения/регистрации.
- В `integration_logs` за последние 2 часа отсутствуют записи по `integration_type='retailcrm'` и `event_type='register_module'` — т.е. вызов регистрации не выполнялся.
- В логах сервиса ранее был 500 на `/retailcrm-admin/` из‑за `.format()` и фигурных скобок; это устранено. Также наблюдалась ошибка фонового рефреша кэша (сообщение вида `dictionary update sequence...`) — причина исправлена в коде, требуется перезапуск, чтобы ошибка исчезла из логов.

Блокирующий момент:

- Требуется перезапуск сервисов (`./all.sh restart`) для применения последних изменений (`/retailcrm-admin/api/*`, корректная запись в `integration_logs`, фикс кэша). Без этого UI работает, но POST‑маршруты страницы могут указывать на отсутствующие в текущем процессе обработчики, поэтому сохранение и регистрация фактически не происходят и в БД/логах не отражаются.

Следующие шаги после перезапуска:

1) На странице `retailcrm-admin` снова нажать «Сохранить и зарегистрировать».
2) Проверить:
   - `enterprises.integrations_config->retailcrm` обновился домен+ключ.
   - В `integration_logs` появилась запись `event_type=register_module` со `status=success|error` и деталями ответа RetailCRM.
3) При `success=true` модуль "Vochi‑CRM" должен отобразиться в кабинете RetailCRM; при ошибке — текст ошибки виден в `error_message` и логах сервиса.

---

## Авторизация для кнопки "Перейти в личный кабинет" из RetailCRM

### Проблема
- В RetailCRM в модуле интеграции есть кнопка "Перейти в личный кабинет" (`accountUrl`)
- URL ведёт на `https://bot.vochi.by/retailcrm-admin/?enterprise_number=0367`
- Наш сервис защищён `AuthMiddleware` — маршрут `/retailcrm-admin/` НЕ входит в `PUBLIC_ROUTES`
- Пользователь RetailCRM не имеет `session_token` cookie для авторизации

### Рассмотренные варианты решения

#### 1️⃣ Простое добавление в PUBLIC_ROUTES
```python
PUBLIC_ROUTES = {"/retailcrm-admin", ...}  # Добавить маршрут
```
**Плюсы:** Очень просто  
**Минусы:** Нет защиты — любой может зайти

#### 2️⃣ JWT токены в URL (ВЫБРАННОЕ РЕШЕНИЕ)
- Генерировать долгосрочные JWT токены при регистрации модуля
- Обновлять `accountUrl`: `.../?enterprise_number=0367&token=<jwt_token>`
- Модифицировать middleware для поддержки RetailCRM токенов
- Создавать временные admin-сессии для работы с интерфейсом

**Плюсы:**
- ✅ Безопасно (токен привязан к предприятию)
- ✅ Автоматическая авторизация одним кликом
- ✅ Можно отозвать токены при удалении интеграции
- ✅ Не влияет на остальные процессы авторизации

**Минусы:**
- ⚠️ Нужно модифицировать middleware (минимально)
- ⚠️ Токен видно в URL (но это стандартная практика)

#### 3️⃣ API ключи RetailCRM для верификации
- Проверять подлинность через обратные вызовы к API RetailCRM
- Создавать verification_code для подтверждения

**Плюсы:** Высокая безопасность  
**Минусы:** Сложная реализация, зависимость от RetailCRM API

#### 4️⃣ Специальная авторизация только для админов
- Отдельный механизм для администраторов предприятий
- Создание временных admin-пользователей

**Плюсы:** Гибкость  
**Минусы:** Дублирование логики авторизации

### План реализации выбранного решения (JWT токены)

1. **Модификация AuthMiddleware** для поддержки RetailCRM токенов:
   ```python
   if path.startswith("/retailcrm-admin/"):
       return await handle_retailcrm_admin_auth(request, call_next)
   ```

2. **Генерация JWT токенов** при регистрации модуля:
   ```python
   def generate_retailcrm_access_token(enterprise_number: str) -> str:
       payload = {
           "enterprise_number": enterprise_number,
           "source": "retailcrm",
           "exp": datetime.utcnow() + timedelta(days=365),
           "iat": datetime.utcnow()
       }
       return jwt.encode(payload, JWT_SECRET_KEY, algorithm="HS256")
   ```

3. **Обновление accountUrl** с токеном в модуле интеграции

4. **Безопасность:**
   - Токен привязан к конкретному предприятию
   - Имеет срок действия (1 год, обновляется при перерегистрации)
   - Автоматически отзывается при удалении интеграции
   - Работает только для админки RetailCRM

5. **Пользовательский опыт:**
   - Один клик из RetailCRM → сразу в админку
   - Автоматическое определение предприятия
   - Не требует дополнительной авторизации

### Гарантии безопасности
- ✅ Токены не влияют на основную систему авторизации
- ✅ Доступ только к админке RetailCRM конкретного предприятия
- ✅ Автоматическая ротация токенов при перерегистрации
- ✅ Возможность отзыва при удалении интеграции
- ✅ Изолированный механизм авторизации

**Статус:** ✅ Реализовано и работает

---

## Playwright: Тестирование интеграции RetailCRM

### Маршрут входа в интеграцию через Playwright

```python
# 1. Логин в RetailCRM
await page.goto("https://retailcrm.ru")
await page.fill('input[name="username"]', "evgeny.baevski@gmail.com")
await page.fill('input[name="password"]', "47916565+")
await page.click('button[type="submit"]')

# 2. Переход в личный кабинет
await page.goto("https://evgenybaevski.retailcrm.ru")

# 3. Настройки → Маркетплейс
await page.click('a[href="/admin/settings"]')
await page.click('a[href="/admin/marketplace"]')

# 4. Поиск интеграции Vochi-CRM
await page.click('text="Прочее"')  # Раздел "Прочее"
await page.click('.marketplace-card:has-text("Vochi-CRM")')

# 5. Переход к редактированию интеграции
await page.goto("https://evgenybaevski.retailcrm.ru/admin/integration/vochi-telephony/edit")

# 6. Тест кнопки "Перейти в личный кабинет"
await page.click('button:has-text("Перейти в личный кабинет")')
# Должна открыться новая вкладка: https://bot.vochi.by/retailcrm-admin/?enterprise_number=0367&token=...
```

### Проверки после клика по кнопке:
1. ✅ Открывается новая вкладка с корректным URL
2. ✅ JWT токен присутствует в URL параметрах
3. ✅ Страница загружается без ошибок авторизации
4. ✅ Отображается админка предприятия с корректным названием
5. ✅ Кнопки "Сохранить и зарегистрировать" и "Удалить интеграцию" работают

### Возможные проблемы и решения:
- **405 Method Not Allowed**: Добавлен POST маршрут к GET `/retailcrm-admin/`
- **Ошибки авторизации**: JWT токен валидируется в AuthMiddleware
- **Пустая страница**: Проверить генерацию токена при регистрации модуля
- **Старый токен в кэше**: Перерегистрировать интеграцию для получения нового токена

**Статус:** ✅ Протестировано и работает