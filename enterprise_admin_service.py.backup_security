# -*- coding: utf-8 -*-
import uvicorn
from fastapi import FastAPI, Request, Form, Depends, HTTPException, Query, status, Body, UploadFile, File
from fastapi.responses import HTMLResponse, RedirectResponse, JSONResponse, Response, FileResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
import asyncpg
import logging
from typing import Dict, Optional, List
import jwt
from datetime import datetime
import random
import string
from pydantic import BaseModel
import time
import os
import uuid
import asyncio
import re
from pathlib import Path
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
import shutil
import httpx

from app.config import JWT_SECRET_KEY, POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB, POSTGRES_HOST, POSTGRES_PORT

# A set of reserved numbers that cannot be assigned.
RESERVED_INTERNAL_NUMBERS = {301, 302, 555}

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–æ—Ä–Ω–µ–≤—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞
# __file__ -> enterprise_admin_service.py
# .parent -> /
# .parent -> /root/asterisk-webhook (–ø—Ä–æ–µ–∫—Ç)
PROJECT_ROOT = Path(__file__).resolve().parent

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
# Pydantic Models (defined locally to avoid import issues)
# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

class UserUpdate(BaseModel):
    email: str
    last_name: str
    first_name: str
    patronymic: Optional[str] = None
    personal_phone: Optional[str] = None
    internal_phones: Optional[List[str]] = None
    # –ü–æ–ª—è —Ä–æ–ª–µ–π
    is_admin: bool = False
    is_employee: bool = True
    is_marketer: bool = False
    is_spec1: bool = False
    is_spec2: bool = False

class UserCreate(UserUpdate):
    pass

class CreateLineRequest(BaseModel):
    phone_number: str
    password: str

class MusicFileCreate(BaseModel):
    display_name: str
    file_type: str

class SipLineCreate(BaseModel):
    provider_id: int
    line_name: str
    password: str
    prefix: Optional[str] = None

class SipLineUpdate(SipLineCreate):
    pass

class DepartmentCreate(BaseModel):
    name: str
    number: int

class DepartmentUpdate(BaseModel):
    name: str
    number: int
    members: Optional[List[int]] = None # –°–ø–∏—Å–æ–∫ ID –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏x –Ω–æ–º–µ—Ä–æ–≤ (internal_phone_id)

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
# Basic Configuration
# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

app = FastAPI()

@app.middleware("http")
async def log_all_requests_middleware(request: Request, call_next):
    """
    Middleware –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Å–µ—Ö –≤—Ö–æ–¥—è—â–∏—Ö HTTP –∑–∞–ø—Ä–æ—Å–æ–≤.
    """
    start_time = time.time()
    logger.info(f"–ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å: {request.method} {request.url}")

    response = await call_next(request)

    process_time = time.time() - start_time
    logger.info(f"–ó–∞–ø—Ä–æ—Å –æ–±—Ä–∞–±–æ—Ç–∞–Ω –∑–∞ {process_time:.4f} —Å–µ–∫. –°—Ç–∞—Ç—É—Å: {response.status_code}. –ê–¥—Ä–µ—Å: {request.method} {request.url}")

    return response

app.mount("/static", StaticFiles(directory="app/static"), name="static")
app.mount("/music", StaticFiles(directory="music"), name="music")

templates = Jinja2Templates(directory="templates", auto_reload=True)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Add a handler for log_action.txt
log_action_handler = logging.FileHandler("log_action.txt", mode='a')
log_action_handler.setLevel(logging.INFO)
log_action_handler.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
logger.addHandler(log_action_handler)

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
# Database Functions
# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

DB_CONFIG = {
    "user": "postgres",
    "password": "r/Yskqh/ZbZuvjb2b3ahfg==",
    "host": "localhost",
    "port": 5432,
    "database": "postgres"
}

async def get_db_connection():
    try:
        conn = await asyncpg.connect(user=DB_CONFIG["user"], password=DB_CONFIG["password"], database=DB_CONFIG["database"], host=DB_CONFIG["host"], port=DB_CONFIG["port"])
        return conn
    except asyncpg.PostgresError as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö: {e}")
        return None

async def get_enterprise_by_number_from_db(number: str) -> Optional[Dict]:
    conn = await get_db_connection()
    if conn:
        try:
            row = await conn.fetchrow("SELECT id, number, name FROM enterprises WHERE number = $1", number)
            return dict(row) if row else None
        finally:
            await conn.close()
    return None

async def get_file_path_from_db(file_id: int, enterprise_number: str) -> Optional[str]:
    conn = await get_db_connection()
    if not conn: return None
    try:
        path = await conn.fetchval(
            "SELECT file_path FROM music_files WHERE id = $1 AND enterprise_number = $2",
            file_id, enterprise_number
        )
        return path
    finally:
        await conn.close()

async def _generate_sip_addproviders_conf(conn, enterprise_number: str) -> str:
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞ sip_addproviders.conf –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –ë–î.
    –ü–æ—Ä—è–¥–æ–∫: gsm-–ª–∏–Ω–∏–∏, –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –Ω–æ–º–µ—Ä–∞, sip-–ª–∏–Ω–∏–∏.
    """
    content_parts = []
    
    # 1. GSM-–ª–∏–Ω–∏–∏ (—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ line_id)
    try:
        gsm_lines = await conn.fetch(
            "SELECT line_id FROM gsm_lines WHERE enterprise_number = $1 ORDER BY line_id",
            enterprise_number
        )
        for line in gsm_lines:
            context = f"""
[{line['line_id']}]
host=dynamic
type=peer
secret=4bfX5XuefNp3aksfhj232
callgroup=1
pickupgroup=1
disallow=all
allow=ulaw
context=from-out-office
directmedia=no
nat=force_rport,comedia
qualify=8000
insecure=invite
defaultuser=s
""".strip()
            content_parts.append(context)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ GSM-–ª–∏–Ω–∏–π –¥–ª—è –∫–æ–Ω—Ñ–∏–≥–∞: {e}", exc_info=True)


    # 2. –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –ª–∏–Ω–∏–∏ (—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –Ω–æ–º–µ—Ä—É)
    try:
        internal_lines = await conn.fetch(
            "SELECT phone_number, password FROM user_internal_phones WHERE enterprise_number = $1 ORDER BY phone_number::integer",
            enterprise_number
        )
        for line in internal_lines:
            context = f"""
[{line['phone_number']}]
host=dynamic
type=friend
secret={line['password']}
callgroup=1
pickupgroup=1
disallow=all
allow=ulaw
context=inoffice
directmedia=no
nat=force_rport,comedia
qualify=8000
insecure=invite
callerid={line['phone_number']}
defaultuser={line['phone_number']}
""".strip()
            content_parts.append(context)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –ª–∏–Ω–∏–π –¥–ª—è –∫–æ–Ω—Ñ–∏–≥–∞: {e}", exc_info=True)


    # 3. SIP-–ª–∏–Ω–∏–∏ (—Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ id)
    try:
        sip_lines = await conn.fetch(
            "SELECT line_name, info FROM sip_unit WHERE enterprise_number = $1 ORDER BY id",
            enterprise_number
        )
        for line in sip_lines:
            # –¢–µ–ª–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –±–µ—Ä–µ—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é –∏–∑ –ø–æ–ª—è 'info'
            context = f"[{line['line_name']}]\n{line['info']}".strip()
            content_parts.append(context)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ SIP-–ª–∏–Ω–∏–π –¥–ª—è –∫–æ–Ω—Ñ–∏–≥–∞: {e}", exc_info=True)

    return "\n\n".join(content_parts)

async def _regenerate_sip_config_via_plan_service(enterprise_number: str) -> dict:
    """–í—ã–∑—ã–≤–∞–µ—Ç –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è sip_addproviders.conf"""
    try:
        async with httpx.AsyncClient() as client:
            plan_service_url = f"http://localhost:8006/generate_sip_config"
            response = await client.post(
                plan_service_url, 
                json={"enterprise_id": enterprise_number}, 
                timeout=30.0
            )
            response.raise_for_status()
            result = response.json()
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç –æ—Ç –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å–∞
            deployment_info = result.get("deployment", {})
            deployment_success = deployment_info.get("success", False)
            deployment_message = deployment_info.get("message", "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
            
            if deployment_success:
                logger.info(f"–£—Å–ø–µ—à–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ SIP –∫–æ–Ω—Ñ–∏–≥–∞ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}")
                return {
                    "status": "success", 
                    "detail": "–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è SIP –æ–±–Ω–æ–≤–ª–µ–Ω–∞"
                }
            else:
                logger.warning(f"SIP –∫–æ–Ω—Ñ–∏–≥ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω, –Ω–æ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}: {deployment_message}")
                return {
                    "status": "warning", 
                    "detail": "–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ"
                }
                
    except httpx.TimeoutException:
        logger.error(f"Timeout –ø—Ä–∏ –≤—ã–∑–æ–≤–µ –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å–∞ –¥–ª—è SIP –∫–æ–Ω—Ñ–∏–≥–∞ –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}")
        return {"status": "error", "detail": "–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ"}
    except httpx.RequestError as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å–∞ –¥–ª—è SIP –∫–æ–Ω—Ñ–∏–≥–∞ –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}: {e}")
        return {"status": "error", "detail": "–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ"}
    except Exception as e:
        logger.error(f"–ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ SIP –∫–æ–Ω—Ñ–∏–≥–∞ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}: {e}", exc_info=True)
        return {"status": "error", "detail": "–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ"}

async def _deploy_single_audio_file_to_asterisk(enterprise_number: str, file_path: str, file_type: str, internal_filename: str) -> dict:
    """–î–µ–ø–ª–æ–π –æ–¥–Ω–æ–≥–æ –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞ –Ω–∞ —É–¥–∞–ª–µ–Ω–Ω—ã–π —Ö–æ—Å—Ç"""
    try:
        async with httpx.AsyncClient() as client:
            if file_type in ["start", "hold"]:
                # –†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–µ–º —Ñ–∞–π–ª —á–µ—Ä–µ–∑ –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å
                plan_service_url = f"http://localhost:8006/deploy_audio_files"
                response = await client.post(
                    plan_service_url, 
                    json={"enterprise_id": enterprise_number}, 
                    timeout=30.0
                )
                response.raise_for_status()
                result = response.json()
                
                deployment_info = result.get("deployment", {})
                deployment_success = deployment_info.get("success", False)
                deployment_message = deployment_info.get("message", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞")
                
                logging.info(f"Audio file deployment result for {enterprise_number}: {deployment_message}")
                return {"success": deployment_success, "message": deployment_message}
            
            else:
                return {"success": True, "message": "–¢–∏–ø —Ñ–∞–π–ª–∞ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è"}
        
    except httpx.HTTPStatusError as e:
        logging.error(f"HTTP error during audio file deployment to plan service: {e}")
        return {"success": False, "message": "–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ"}
    except httpx.TimeoutException:
        logging.error(f"Timeout during audio file deployment to plan service")
        return {"success": False, "message": "–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ"}
    except Exception as e:
        logging.error(f"Unexpected error during audio file deployment: {str(e)}")
        return {"success": False, "message": "–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ"}

async def _deploy_all_audio_files_to_asterisk(enterprise_number: str) -> dict:
    """–î–µ–ø–ª–æ–π –≤—Å–µ—Ö –∞—É–¥–∏–æ—Ñ–∞–π–ª–æ–≤ –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è –Ω–∞ —É–¥–∞–ª–µ–Ω–Ω—ã–π —Ö–æ—Å—Ç (–∫–Ω–æ–ø–∫–∞ –û–±–Ω–æ–≤–∏—Ç—å)"""
    try:
        async with httpx.AsyncClient() as client:
            plan_service_url = f"http://localhost:8006/deploy_audio_files"
            response = await client.post(
                plan_service_url, 
                json={"enterprise_id": enterprise_number}, 
                timeout=60.0  # –ë–æ–ª—å—à–∏–π timeout –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è
            )
            response.raise_for_status()
            result = response.json()
            
            deployment_info = result.get("deployment", {})
            deployment_success = deployment_info.get("success", False)
            deployment_message = deployment_info.get("message", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞")
            
            logging.info(f"Full audio deployment result for {enterprise_number}: {deployment_message}")
            return {"success": deployment_success, "message": deployment_message}
        
    except httpx.HTTPStatusError as e:
        logging.error(f"HTTP error during full audio deployment to plan service: {e}")
        return {"success": False, "message": "–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ"}
    except httpx.TimeoutException:
        logging.error(f"Timeout during full audio deployment to plan service")
        return {"success": False, "message": "–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ"}
    except Exception as e:
        logging.error(f"Unexpected error during full audio deployment: {str(e)}")
        return {"success": False, "message": "–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ"}

async def _generate_musiconhold_conf(conn, enterprise_number: str) -> str:
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞ musiconhold.conf –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –ë–î.
    """
    base_content = """
;
; Music on Hold -- Sample Configuration
;
[general]
;cachertclasses=yes
[default]
mode=files
directory=moh
""".strip()

    hold_files = await conn.fetch(
        "SELECT internal_filename FROM music_files WHERE enterprise_number = $1 AND file_type = 'hold'",
        enterprise_number
    )

    dynamic_parts = []
    for file in hold_files:
        if file['internal_filename'] and file['internal_filename'].endswith('.wav'):
            context_name = file['internal_filename'][:-4] # –£–±–∏—Ä–∞–µ–º .wav
            part = f"""
[{context_name}]
mode=files
directory={context_name}
sort=random
""".strip()
            dynamic_parts.append(part)

    full_content = base_content + "\n\n" + "\n\n".join(dynamic_parts)
    return full_content

async def _generate_and_write_sip_config(conn, enterprise_number: str):
    """
    –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∏ –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ñ–∞–π–ª sip_addproviders.conf –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –ë–î.
    """
    try:
        config_dir = Path(f"music/{enterprise_number}")
        config_dir.mkdir(parents=True, exist_ok=True)
        config_path = config_dir / "sip_addproviders.conf"
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø–æ–ª–Ω–æ–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞
        full_config_content = await _generate_sip_addproviders_conf(conn, enterprise_number)
        
        with open(config_path, "w") as f:
            f.write(full_config_content)
        logger.info(f"–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ñ–∞–π–ª '{config_path}' —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω/–æ–±–Ω–æ–≤–ª–µ–Ω –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}.")
    except Exception as e:
        logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å/–æ–±–Ω–æ–≤–∏—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–π —Ñ–∞–π–ª: {e}", exc_info=True)

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
# Authentication
# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

@app.get("/", response_class=HTMLResponse)
async def root_login_form(request: Request):
    return templates.TemplateResponse("enterprise_admin/login.html", {"request": request, "error": None})

@app.get("/auth/{token}", response_class=RedirectResponse)
async def auth_by_token(token: str):
    logger.info(f"–ü–æ–ø—ã—Ç–∫–∞ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ —Å —Ç–æ–∫–µ–Ω–æ–º: {token[:15]}...")
    try:
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=["HS256"])
        logger.info(f"–¢–æ–∫–µ–Ω —É—Å–ø–µ—à–Ω–æ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω. Payload: {payload}")

        if not payload.get("is_admin"):
            logger.warning(f"–¢–æ–∫–µ–Ω –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –∞–¥–º–∏–Ω—Å–∫–∏–º. Payload: {payload}")
            raise HTTPException(status_code=403, detail="Not an admin token")
        
        enterprise_number = payload["sub"]
        logger.info(f"–ù–æ–º–µ—Ä –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è –∏–∑ —Ç–æ–∫–µ–Ω–∞: {enterprise_number}")

        session_token = f"session_admin_{datetime.utcnow().timestamp()}_{random.random()}"

        conn = await get_db_connection()
        if not conn:
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –ë–î –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Å–µ—Å—Å–∏–∏.")
            raise HTTPException(status_code=500, detail="DB Connection failed")
        
        try:
            logger.info(f"–°–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Å—Å–∏–∏ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}...")
            await conn.execute("INSERT INTO sessions (session_token, enterprise_number) VALUES ($1, $2)", session_token, enterprise_number)
            logger.info(f"–°–µ—Å—Å–∏—è —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞. –¢–æ–∫–µ–Ω —Å–µ—Å—Å–∏–∏: {session_token[:15]}...")
        finally:
            await conn.close()

        response = RedirectResponse(url=f"/enterprise/{enterprise_number}/dashboard", status_code=status.HTTP_303_SEE_OTHER)
        response.set_cookie(key="session_token", value=session_token, httponly=True, samesite="lax", max_age=48*3600, secure=True) # Set secure=True in production
        logger.info(f"–ü–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –Ω–∞ –¥–∞—à–±–æ—Ä–¥ –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}.")
        return response
    except jwt.ExpiredSignatureError:
        logger.warning(f"–ò—Å—Ç–µ–∫ —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è —Ç–æ–∫–µ–Ω–∞: {token[:15]}...")
        return RedirectResponse(url="/?error=invalid_token")
    except jwt.InvalidTokenError:
        logger.error(f"–ù–µ–≤–∞–ª–∏–¥–Ω—ã–π —Ç–æ–∫–µ–Ω: {token[:15]}...")
        return RedirectResponse(url="/?error=invalid_token")
    except Exception as e:
        logger.error(f"–ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏ –ø–æ —Ç–æ–∫–µ–Ω—É: {e}", exc_info=True)
        return RedirectResponse(url="/?error=unexpected_error")

async def get_current_enterprise(request: Request) -> str:
    session_token = request.cookies.get("session_token")
    if not session_token:
        raise HTTPException(status_code=status.HTTP_307_TEMPORARY_REDIRECT, headers={"Location": "/"})
    
    conn = await get_db_connection()
    if not conn: raise HTTPException(status_code=500, detail="DB connection error")

    try:
        row = await conn.fetchrow("SELECT enterprise_number FROM sessions WHERE session_token = $1", session_token)
        if not row:
            response = RedirectResponse(url="/")
            response.delete_cookie("session_token")
            raise HTTPException(status_code=status.HTTP_307_TEMPORARY_REDIRECT, headers={"Location": "/"})
        return row['enterprise_number']
    finally:
        await conn.close()

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
# API –¥–ª—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

@app.get("/api/mobiles", response_class=JSONResponse)
async def get_mobiles():
    """
    API –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ —Å –∏—Ö —à–∞–±–ª–æ–Ω–∞–º–∏.
    """
    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö")
    
    try:
        rows = await conn.fetch("SELECT id, name, shablon FROM mobile ORDER BY id")
        mobiles = [dict(row) for row in rows]
        return mobiles
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤: {e}")
        raise HTTPException(status_code=500, detail="–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤")
    finally:
        await conn.close()

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
# Enterprise Admin Dashboard & API
# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

@app.get("/enterprise/{enterprise_number}/dashboard", response_class=HTMLResponse)
async def enterprise_dashboard(request: Request, enterprise_number: str):
    logger.info(f"DASHBOARD: –ó–∞–ø—Ä–æ—Å –¥–∞—à–±–æ—Ä–¥–∞ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}")
    # –£–±—Ä–∞–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ current_enterprise –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∏–∑ user –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
    enterprise = await get_enterprise_by_number_from_db(enterprise_number)
    if not enterprise:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="–ü—Ä–µ–¥–ø—Ä–∏—è—Ç–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
    
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    user = None
    session_token = request.cookies.get("session_token")
    logger.info(f"DASHBOARD: session_token = {session_token}")
    
    if session_token:
        conn = await get_db_connection()
        if conn:
            try:
                # –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º –≤ user_sessions (user –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è)
                user_row = await conn.fetchrow("""
                    SELECT u.id, u.first_name, u.last_name, u.email, u.enterprise_number
                    FROM user_sessions s 
                    JOIN users u ON s.user_id = u.id 
                    WHERE s.session_token = $1 AND s.expires_at > NOW()
                """, session_token)
                
                if user_row:
                    user = dict(user_row)
                    logger.info(f"DASHBOARD: –ù–∞–π–¥–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏–∑ user_sessions: {user}")
                else:
                    # –ï—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ user_sessions, –∏—â–µ–º –≤ sessions (super admin)
                    logger.info(f"DASHBOARD: –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ user_sessions, –ø—Ä–æ–≤–µ—Ä—è–µ–º sessions (super admin)")
                    session_row = await conn.fetchrow("""
                        SELECT session_token FROM sessions 
                        WHERE session_token = $1 AND created_at > NOW() - INTERVAL '24 hours'
                    """, session_token)
                    
                    if session_row:
                        # –î–ª—è super admin'–∞ - –±–µ—Ä–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ enterprise_number
                        admin_user_row = await conn.fetchrow("""
                            SELECT u.id, u.first_name, u.last_name, u.email, u.enterprise_number
                            FROM users u 
                            WHERE u.enterprise_number = $1 AND u.is_admin = true
                            LIMIT 1
                        """, enterprise_number)
                        
                        if admin_user_row:
                            user = dict(admin_user_row)
                            logger.info(f"DASHBOARD: –ù–∞–π–¥–µ–Ω admin –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏–∑ sessions: {user}")
                        else:
                            logger.info(f"DASHBOARD: Admin –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}")
                    else:
                        logger.info(f"DASHBOARD: –¢–æ–∫–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω –Ω–∏ –≤ user_sessions, –Ω–∏ –≤ sessions")
            except Exception as e:
                logger.error(f"DASHBOARD: –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {e}")
            finally:
                await conn.close()
    else:
        logger.info("DASHBOARD: session_token –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ cookies")
    
    logger.info(f"DASHBOARD: –ü–µ—Ä–µ–¥–∞—é –≤ —à–∞–±–ª–æ–Ω: enterprise={enterprise}, user={user}")
    
    return templates.TemplateResponse("enterprise_admin/dashboard.html", {
        "request": request, 
        "enterprise": enterprise,
        "user": user
    })

@app.get("/enterprise/{enterprise_number}/users", response_class=JSONResponse)
async def get_enterprise_users(enterprise_number: str):
    # –£–±—Ä–∞–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ current_enterprise –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∏–∑ —Å—É–ø–µ—Ä–∞–¥–º–∏–Ω–∞
    
    conn = await get_db_connection()
    if not conn: raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        sql_query = """
            SELECT * FROM (
                WITH personal_incoming_schemas AS (
                    SELECT 
                        user_id, 
                        array_agg(schema_name) AS incoming_schema_names
                    FROM user_personal_phone_incoming_assignments
                    WHERE enterprise_number = $1
                    GROUP BY user_id
                ),
                internal_incoming_schemas AS (
                    SELECT 
                        internal_phone_id, 
                        array_agg(schema_name) AS incoming_schema_names
                    FROM user_internal_phone_incoming_assignments
                    WHERE enterprise_number = $1
                    GROUP BY internal_phone_id
                )
                SELECT 
                    u.id AS user_id,
                    u.first_name,
                    u.last_name,
                    u.patronymic,
                    TRIM(COALESCE(u.last_name, '') || ' ' || COALESCE(u.first_name, '')) AS full_name,
                    u.email,
                    u.personal_phone AS phone_number,
                    'user' AS line_type,
                    COALESCE(pis.incoming_schema_names, ARRAY[]::varchar[]) AS incoming_schema_names,
                    NULL AS outgoing_schema_name,
                    NULL AS ip_registration,
                    NULL AS role,
                    NULL AS department
                FROM users u
                LEFT JOIN personal_incoming_schemas pis ON u.id = pis.user_id
                WHERE u.enterprise_number = $1 AND u.personal_phone IS NOT NULL

                UNION ALL

                SELECT 
                    uip.user_id,
                    u.first_name,
                    u.last_name,
                    u.patronymic,
                    TRIM(COALESCE(u.last_name, '') || ' ' || COALESCE(u.first_name, '')) AS full_name,
                    u.email,
                    uip.phone_number,
                    'internal' AS line_type,
                    COALESCE(iis.incoming_schema_names, ARRAY[]::varchar[]) AS incoming_schema_names,
                    ds.schema_name AS outgoing_schema_name,
                    NULL AS ip_registration,
                    CASE 
                        WHEN u.is_admin THEN '–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä'
                        WHEN u.is_employee THEN '–°–æ—Ç—Ä—É–¥–Ω–∏–∫'
                        WHEN u.is_marketer THEN '–ú–∞—Ä–∫–µ—Ç–æ–ª–æ–≥'
                        WHEN u.is_spec1 THEN 'Spec1'
                        WHEN u.is_spec2 THEN 'Spec2'
                        ELSE '–ù–µ —É–∫–∞–∑–∞–Ω–æ'
                    END AS role,
                    NULL AS department
                FROM user_internal_phones uip
                LEFT JOIN users u ON uip.user_id = u.id
                LEFT JOIN dial_schemas ds ON uip.outgoing_schema_id = ds.schema_id
                LEFT JOIN internal_incoming_schemas iis ON uip.id = iis.internal_phone_id
                WHERE uip.enterprise_number = $1
            ) AS combined_users
            ORDER BY 
                last_name, 
                first_name, 
                CASE 
                    WHEN line_type = 'internal' THEN 1
                    WHEN line_type = 'user' THEN 2
                    ELSE 3
                END,
                phone_number;
        """
        
        users_and_lines = await conn.fetch(sql_query, enterprise_number)
        
        # –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ª–∏–Ω–∏–∏ –ø–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º
        users_data = {}
        for record in users_and_lines:
            user_id = record['user_id']
            if user_id not in users_data:
                users_data[user_id] = {
                    "user_id": user_id,
                    "full_name": record['full_name'],
                    "email": record['email'],
                    "role": record.get('role', '–ù–µ —É–∫–∞–∑–∞–Ω–æ'),
                    "department": record.get('department', ''),
                    "lines": []
                }
            
            users_data[user_id]['lines'].append({
                "phone_number": record['phone_number'],
                "line_type": record['line_type'],
                "incoming_schema_names": record['incoming_schema_names'] or [],
                "outgoing_schema_name": record['outgoing_schema_name'],
                "ip_registration": record.get('ip_registration'),
                "role": record.get('role', '–ù–µ —É–∫–∞–∑–∞–Ω–æ'),
                "department": record.get('department', '')
            })

        logger.info(f"–ù–∞–π–¥–µ–Ω–æ {len(users_data)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}")
        return JSONResponse(content=list(users_data.values()))
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∏ –ª–∏–Ω–∏–π –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        if conn:
            await conn.close()

@app.get("/enterprise/{enterprise_number}/internal-phones/all", response_class=JSONResponse)
async def get_all_internal_phones(enterprise_number: str, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    
    conn = await get_db_connection()
    if not conn: raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        query = """
        SELECT p.id, p.phone_number, p.user_id, (u.first_name || ' ' || u.last_name) AS manager_name
        FROM user_internal_phones p LEFT JOIN users u ON p.user_id = u.id
        WHERE p.enterprise_number = $1 ORDER BY (CASE WHEN p.phone_number ~ '^[0-9]+$' THEN p.phone_number::int END)
        """
        rows = await conn.fetch(query, enterprise_number)
        return JSONResponse(content=[dict(row) for row in rows])
    finally:
        await conn.close()

@app.get("/enterprise/{enterprise_number}/internal-phones/next-available", response_class=JSONResponse)
async def get_next_available_number(enterprise_number: str, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    conn = await get_db_connection()
    if not conn: raise HTTPException(status_code=500, detail="DB connection failed")
    try:
        rows = await conn.fetch("SELECT phone_number FROM user_internal_phones WHERE enterprise_number = $1 AND phone_number ~ '^[0-9]+$'", enterprise_number)
        existing_numbers = {int(row['phone_number']) for row in rows if row['phone_number']}
        
        for num in range(150, 900):
            if num not in existing_numbers and num not in RESERVED_INTERNAL_NUMBERS:
                return JSONResponse(content={"next_number": num})
        for num in range(100, 150):
            if num not in existing_numbers and num not in RESERVED_INTERNAL_NUMBERS:
                return JSONResponse(content={"next_number": num})
        return JSONResponse(content={"error": "No available numbers in range 100-899"}, status_code=404)
    finally:
        await conn.close()

@app.post("/enterprise/{enterprise_number}/users", status_code=status.HTTP_201_CREATED)
async def create_user(enterprise_number: str, user_data: UserCreate):
    conn = await get_db_connection()
    if not conn: raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        async with conn.transaction():
            # –®–∞–≥ 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã
            existing_user_by_email = await conn.fetchrow("SELECT id FROM users WHERE email = $1 AND enterprise_number = $2", user_data.email, enterprise_number)
            if existing_user_by_email:
                raise HTTPException(status_code=400, detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")

            if user_data.personal_phone:
                existing_user_by_phone = await conn.fetchrow("SELECT id FROM users WHERE personal_phone = $1 AND enterprise_number = $2", user_data.personal_phone, enterprise_number)
                if existing_user_by_phone:
                    raise HTTPException(status_code=400, detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –≤–Ω–µ—à–Ω–∏–º –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")

            # –®–∞–≥ 2: –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            new_user_id = await conn.fetchval(
                """
                INSERT INTO users (enterprise_number, email, first_name, last_name, patronymic, personal_phone, status,
                                 is_admin, is_employee, is_marketer, is_spec1, is_spec2)
                VALUES ($1, $2, $3, $4, $5, $6, 'active', $7, $8, $9, $10, $11)
                RETURNING id
                """,
                enterprise_number, user_data.email, user_data.first_name, user_data.last_name,
                user_data.patronymic, user_data.personal_phone,
                user_data.is_admin, user_data.is_employee, user_data.is_marketer, user_data.is_spec1, user_data.is_spec2
            )

            # –®–∞–≥ 3: –ü—Ä–∏–≤—è–∑–∫–∞ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –Ω–æ–º–µ—Ä–æ–≤
            if user_data.internal_phones:
                # –°–Ω–∞—á–∞–ª–∞ –æ—Ç–≤—è–∑—ã–≤–∞–µ–º —ç—Ç–∏ –Ω–æ–º–µ—Ä–∞ –æ—Ç –ª—é–±–æ–≥–æ –¥—Ä—É–≥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π)
                await conn.execute("UPDATE user_internal_phones SET user_id = NULL WHERE enterprise_number = $1 AND phone_number = ANY($2::text[])",
                                   enterprise_number, user_data.internal_phones)
                # –ó–∞—Ç–µ–º –ø—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫ –Ω–æ–≤–æ–º—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
                await conn.execute("UPDATE user_internal_phones SET user_id = $1 WHERE enterprise_number = $2 AND phone_number = ANY($3::text[])",
                                   new_user_id, enterprise_number, user_data.internal_phones)

        return {"status": "success", "user_id": new_user_id}
    except asyncpg.exceptions.UniqueViolationError: # Fallback for race conditions
        raise HTTPException(status_code=400, detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email –∏–ª–∏ —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")
    finally:
        await conn.close()

@app.delete("/enterprise/{enterprise_number}/users/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user(enterprise_number: str, user_id: int, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏ –µ—Å—Ç—å –ª–∏ —É –Ω–µ–≥–æ –≤–Ω–µ—à–Ω–∏–π –Ω–æ–º–µ—Ä
        user = await conn.fetchrow("SELECT id, personal_phone FROM users WHERE id = $1 AND enterprise_number = $2", user_id, enterprise_number)
        if not user:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")

        # –ï—Å–ª–∏ –≤–Ω–µ—à–Ω–∏–π –Ω–æ–º–µ—Ä –µ—Å—Ç—å, –ø—Ä–æ–≤–µ—Ä—è–µ–º –µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ —Å—Ö–µ–º–∞—Ö
        if user['personal_phone']:
            assigned_schemas = await conn.fetch(
                """
                SELECT schema_name FROM user_personal_phone_incoming_assignments
                WHERE user_id = $1 AND enterprise_number = $2
                """,
                user_id, enterprise_number
            )
            if assigned_schemas:
                schema_names = [record['schema_name'] for record in assigned_schemas]
                detail_message = f"–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è. –ï–≥–æ –≤–Ω–µ—à–Ω–∏–π –Ω–æ–º–µ—Ä –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–æ –≤—Ö–æ–¥—è—â–∏—Ö —Å—Ö–µ–º–∞—Ö: {', '.join(schema_names)}."
                raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=detail_message)

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –µ—Å—Ç—å –ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∞–∫—Ç–∏–≤–Ω–∞—è Telegram –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è
        telegram_user = await conn.fetchrow(
            "SELECT telegram_authorized, telegram_tg_id, email FROM users WHERE id = $1", 
            user_id
        )
        
        # –ï—Å–ª–∏ —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –µ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–∞—è Telegram –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è - –æ—Ç–∑—ã–≤–∞–µ–º –µ—ë
        if telegram_user and telegram_user['telegram_authorized'] and telegram_user['telegram_tg_id']:
            try:
                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram –æ –±–ª–æ–∫–∏—Ä–æ–≤–∫–µ
                import httpx
                telegram_notification = {
                    "tg_id": telegram_user['telegram_tg_id'],
                    "message": f"üö´ –í–∞—à –∞–∫–∫–∞—É–Ω—Ç –±—ã–ª —É–¥–∞–ª–µ–Ω –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è. –î–æ—Å—Ç—É–ø –∫ Telegram-–±–æ—Ç—É –æ—Ç–æ–∑–≤–∞–Ω."
                }
                
                async with httpx.AsyncClient() as client:
                    await client.post(
                        "http://localhost:8016/send_notification",
                        json=telegram_notification,
                        timeout=5
                    )
                    
                logger.info(f"–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –≤ Telegram: {telegram_user['telegram_tg_id']}")
                
                # –û—á–∏—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ telegram_users
                try:
                    cleanup_data = {
                        "tg_id": telegram_user['telegram_tg_id'],
                        "email": telegram_user['email']
                    }
                    
                    async with httpx.AsyncClient() as client:
                        cleanup_response = await client.post(
                            "http://localhost:8016/cleanup_user_data",
                            json=cleanup_data,
                            timeout=5
                        )
                        
                        if cleanup_response.status_code == 200:
                            result = cleanup_response.json()
                            logger.info(f"–û—á–∏—â–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –∏–∑ telegram_users: {result['message']}")
                        else:
                            logger.warning(f"–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –∏–∑ telegram_users: {cleanup_response.status_code}")
                            
                except Exception as cleanup_error:
                    logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—á–∏—Å—Ç–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id} –∏–∑ telegram_users: {cleanup_error}")
                    
            except Exception as telegram_error:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {telegram_error}")
        
        # –û—Ç–≤—è–∑—ã–≤–∞–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –Ω–æ–º–µ—Ä–∞ –æ—Ç —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await conn.execute("UPDATE user_internal_phones SET user_id = NULL WHERE user_id = $1", user_id)

        # –£–¥–∞–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await conn.execute("DELETE FROM users WHERE id = $1", user_id)

    except HTTPException:
        # –ü–æ–≤—Ç–æ—Ä–Ω–æ –≤—ã–∑—ã–≤–∞–µ–º HTTPException, —á—Ç–æ–±—ã FastAPI –æ–±—Ä–∞–±–æ—Ç–∞–ª –µ–≥–æ
        raise
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        await conn.close()

@app.get("/enterprise/{enterprise_number}/users/{user_id}/details_for_edit", response_class=JSONResponse)
async def get_user_details_for_edit(enterprise_number: str, user_id: int, current_enterprise: str = Depends(get_current_enterprise)):
    """
    –≠–Ω–¥–ø–æ–∏–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π –æ—Ç–¥–∞–µ—Ç –ø–æ–ª–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ 
    –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.
    """
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    
    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        user_query = """
            SELECT id, email, first_name, last_name, patronymic, personal_phone,
                   is_admin, is_employee, is_marketer, is_spec1, is_spec2
            FROM users
            WHERE id = $1 AND enterprise_number = $2;
        """
        user_record = await conn.fetchrow(user_query, user_id, enterprise_number)

        if not user_record:
            raise HTTPException(status_code=404, detail="User not found")

        user_details = dict(user_record)

        internal_phones_query = """
            SELECT phone_number 
            FROM user_internal_phones 
            WHERE user_id = $1 AND enterprise_number = $2;
        """
        internal_phones_records = await conn.fetch(internal_phones_query, user_id, enterprise_number)
        
        user_details['internal_phones'] = [record['phone_number'] for record in internal_phones_records]

        return JSONResponse(content=user_details)

    except Exception as e:
        logger.error(f"Failed to fetch user details for edit for user {user_id}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to fetch user details")
    finally:
        if conn:
            await conn.close()

@app.put("/enterprise/{enterprise_number}/users/{user_id}", status_code=status.HTTP_200_OK)
async def update_user(enterprise_number: str, user_id: int, user_data: UserUpdate, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn: raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        # Explicitly check for duplicate email on another user
        existing_user_by_email = await conn.fetchrow("SELECT id FROM users WHERE email = $1 AND enterprise_number = $2 AND id != $3", user_data.email, enterprise_number, user_id)
        if existing_user_by_email:
            raise HTTPException(status_code=400, detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")

        # Explicitly check for duplicate phone on another user
        if user_data.personal_phone:
            existing_user_by_phone = await conn.fetchrow("SELECT id FROM users WHERE personal_phone = $1 AND enterprise_number = $2 AND id != $3", user_data.personal_phone, enterprise_number, user_id)
            if existing_user_by_phone:
                raise HTTPException(status_code=400, detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –≤–Ω–µ—à–Ω–∏–º –Ω–æ–º–µ—Ä–æ–º —Ç–µ–ª–µ—Ñ–æ–Ω–∞ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")

        await conn.execute(
            """UPDATE users SET email = $1, first_name = $2, last_name = $3, patronymic = $4, personal_phone = $5,
               is_admin = $6, is_employee = $7, is_marketer = $8, is_spec1 = $9, is_spec2 = $10
               WHERE id = $11 AND enterprise_number = $12""",
            user_data.email, user_data.first_name, user_data.last_name, user_data.patronymic, user_data.personal_phone,
            user_data.is_admin, user_data.is_employee, user_data.is_marketer, user_data.is_spec1, user_data.is_spec2,
            user_id, enterprise_number
        )
        if user_data.internal_phones is not None:
            async with conn.transaction():
                await conn.execute("UPDATE user_internal_phones SET user_id = NULL WHERE user_id = $1 AND enterprise_number = $2", user_id, enterprise_number)
                if user_data.internal_phones:
                    await conn.execute("UPDATE user_internal_phones SET user_id = $1 WHERE enterprise_number = $2 AND phone_number = ANY($3::text[])",
                                       user_id, enterprise_number, user_data.internal_phones)
        return {"status": "success"}
    except asyncpg.exceptions.UniqueViolationError:
        raise HTTPException(status_code=400, detail="–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email –∏–ª–∏ —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")
    finally:
        await conn.close()

@app.post("/enterprise/{enterprise_number}/internal-phones", response_class=JSONResponse)
async def create_internal_line(enterprise_number: str, data: CreateLineRequest, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    try:
        phone_number_int = int(data.phone_number)
        if not (100 <= phone_number_int <= 899) or phone_number_int in RESERVED_INTERNAL_NUMBERS:
            raise ValueError
    except (ValueError, TypeError):
        raise HTTPException(status_code=400, detail=f"–ù–æ–º–µ—Ä –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç 100 –¥–æ 899 –∏ –Ω–µ –≤—Ö–æ–¥–∏—Ç—å –≤ {RESERVED_INTERNAL_NUMBERS}")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="Database connection failed")

    try:
        query = "INSERT INTO user_internal_phones (enterprise_number, phone_number, password) VALUES ($1, $2, $3) RETURNING id"
        new_line_id = await conn.fetchval(query, enterprise_number, data.phone_number, data.password)

        # –†–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è SIP –∫–æ–Ω—Ñ–∏–≥–∞ —á–µ—Ä–µ–∑ –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ)
        asyncio.create_task(_regenerate_sip_config_via_plan_service(enterprise_number))


        return {"id": new_line_id, "phone_number": data.phone_number, "password": data.password}
    except asyncpg.exceptions.UniqueViolationError:
        raise HTTPException(status_code=400, detail=f"–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –Ω–æ–º–µ—Ä '{data.phone_number}' —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ –Ω–æ–º–µ—Ä–∞: {e}")
        raise HTTPException(status_code=500, detail=f"–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}")
    finally:
        await conn.close()

@app.get("/enterprise/{enterprise_number}/gsm-lines/all", response_class=JSONResponse)
async def get_enterprise_gsm_lines(enterprise_number: str):
    conn = await get_db_connection()
    if not conn: raise HTTPException(status_code=500, detail="DB connection failed")
    try:
        query = """
        SELECT
            g.gateway_name,
            g.custom_boolean_flag,
            gl.id,
            gl.line_id,
            gl.internal_id,
            gl.prefix,
            gl.phone_number,
            gl.line_name,
            gl.in_schema as incoming_schema_name,
            gl.shop,
            gl.slot,
            gl.redirect,
            COALESCE(
                (SELECT array_agg(gosa.schema_name ORDER BY gosa.schema_name)
                 FROM gsm_outgoing_schema_assignments gosa
                 WHERE gosa.gsm_line_id = gl.line_id AND gosa.enterprise_number = $1),
                '{}'::text[]
            ) as outgoing_schema_names
        FROM gsm_lines gl
        LEFT JOIN goip g ON gl.goip_id = g.id
        WHERE gl.enterprise_number = $1
        ORDER BY g.gateway_name, gl.id
        """
        rows = await conn.fetch(query, enterprise_number)
        gateways = {}
        for row in rows:
            gateway_name = row['gateway_name'] or '–ë–µ–∑ —à–ª—é–∑–∞'
            if gateway_name not in gateways:
                gateways[gateway_name] = {
                    'gateway_name': gateway_name,
                    'gateway_id': 0, # –≠—Ç–æ –ø–æ–ª–µ –±–æ–ª—å—à–µ –Ω–µ –∏–º–µ–µ—Ç —Å–º—ã—Å–ª–∞, –Ω–æ –æ—Å—Ç–∞–≤–∏–º –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
                    'is_main': row['custom_boolean_flag'] if row['custom_boolean_flag'] is not None else False,
                    'lines': []
                }
            if row['id'] is not None:
                line = {
                    'id': row['id'],
                    'line_id': row['line_id'],
                    'internal_id': row['internal_id'],
                    'prefix': row['prefix'],
                    'phone_number': row['phone_number'],
                    'line_name': row['line_name'],
                    'incoming_schema_name': row['incoming_schema_name'],
                    'outgoing_schema_names': list(row['outgoing_schema_names'] or []),
                    'shop': row['shop'],
                    'slot': row['slot'],
                    'redirect': row['redirect']
                }
                gateways[gateway_name]['lines'].append(line)
        return JSONResponse(content=list(gateways.values()))
    finally:
        await conn.close()

@app.get("/enterprise/{enterprise_number}/gsm-lines/status", response_class=JSONResponse)
async def get_enterprise_gsm_lines_status(enterprise_number: str, current_enterprise: str = Depends(get_current_enterprise)):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ GSM –ª–∏–Ω–∏–π –Ω–∞ —É–¥–∞–ª–µ–Ω–Ω–æ–º —Ö–æ—Å—Ç–µ Asterisk"""
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    
    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º IP –∞–¥—Ä–µ—Å –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è
        enterprise_query = "SELECT ip FROM enterprises WHERE number = $1"
        enterprise_row = await conn.fetchrow(enterprise_query, enterprise_number)
        
        if not enterprise_row or not enterprise_row['ip']:
            raise HTTPException(status_code=404, detail="IP –∞–¥—Ä–µ—Å –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω")
        
        host_ip = enterprise_row['ip']
        
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ GSM –ª–∏–Ω–∏–∏ –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è
        lines_query = """
        SELECT line_id, internal_id
        FROM gsm_lines 
        WHERE enterprise_number = $1
        ORDER BY line_id
        """
        lines = await conn.fetch(lines_query, enterprise_number)
        
        if not lines:
            return JSONResponse(content={})
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º SSH –∫–æ–º–∞–Ω–¥—É –Ω–∞ —É–¥–∞–ª–µ–Ω–Ω–æ–º —Ö–æ—Å—Ç–µ
        ssh_command = f"sshpass -p '5atx9Ate@pbx' ssh -p 5059 -o ConnectTimeout=5 -o StrictHostKeyChecking=no root@{host_ip} 'asterisk -rx \"sip show peers\"'"
        
        process = await asyncio.create_subprocess_shell(
            ssh_command,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=10)
        
        if process.returncode != 0:
            logger.error(f"SSH –∫–æ–º–∞–Ω–¥–∞ –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π –¥–ª—è {host_ip}: {stderr.decode()}")
            raise HTTPException(status_code=500, detail=f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Ö–æ—Å—Ç—É {host_ip}")
        
        sip_output = stdout.decode('utf-8')
        
        # –ü–∞—Ä—Å–∏–º –≤—ã–≤–æ–¥ sip show peers –¥–ª—è –ø–æ–∏—Å–∫–∞ GSM –ª–∏–Ω–∏–π
        line_status = {}
        
        for line in lines:
            line_id = str(line['line_id']).zfill(7)  # –ü—Ä–∏–≤–æ–¥–∏–º –∫ —Ñ–æ—Ä–º–∞—Ç—É 0001363
            internal_id = line['internal_id']
            
            # –ò—â–µ–º –ª–∏–Ω–∏—é –≤ –≤—ã–≤–æ–¥–µ sip show peers
            ip_address = None
            for sip_line in sip_output.split('\n'):
                if line_id in sip_line:
                    # –†–µ–∞–ª—å–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç: "0001363/s                 213.184.245.128                          D  Yes        Yes            5404     OK (9 ms)"
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º regex –¥–ª—è –∏–∑–≤–ª–µ—á–µ–Ω–∏—è IP –∞–¥—Ä–µ—Å–∞
                    # –ò—â–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω: line_id/s + –ø—Ä–æ–±–µ–ª—ã + IP –∞–¥—Ä–µ—Å + –ø—Ä–æ–±–µ–ª—ã + –æ—Å—Ç–∞–ª—å–Ω–æ–µ
                    pattern = rf'{line_id}/s\s+(\d{{1,3}}\.\d{{1,3}}\.\d{{1,3}}\.\d{{1,3}})'
                    match = re.search(pattern, sip_line)
                    if match and 'OK' in sip_line:
                        ip_address = match.group(1)
                        break
            
            line_status[line['line_id']] = {
                'line_id': line['line_id'],
                'internal_id': internal_id,
                'ip_address': ip_address,
                'status': 'online' if ip_address else 'offline'
            }
        
        return JSONResponse(content=line_status)
        
    except asyncio.TimeoutError:
        raise HTTPException(status_code=408, detail=f"–¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫ —Ö–æ—Å—Ç—É {host_ip}")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å—Ç–∞—Ç—É—Å–∞ GSM –ª–∏–Ω–∏–π –¥–ª—è {enterprise_number}: {e}")
        raise HTTPException(status_code=500, detail=f"–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}")
    finally:
        await conn.close()

@app.get("/enterprise/{enterprise_number}/gsm-lines/{line_id}", response_class=JSONResponse)
async def get_gsm_line(enterprise_number: str, line_id: int):
    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")
    try:
        query = """
        SELECT id, line_id, internal_id, prefix, phone_number, line_name, in_schema, out_schema, shop, slot, redirect
        FROM gsm_lines
        WHERE id = $1 AND enterprise_number = $2
        """
        row = await conn.fetchrow(query, line_id, enterprise_number)
        if not row:
            raise HTTPException(status_code=404, detail="–õ–∏–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
        return dict(row)
    finally:
        await conn.close()

@app.put("/enterprise/{enterprise_number}/gsm-lines/{line_id}", response_class=JSONResponse)
async def update_gsm_line(
    enterprise_number: str,
    line_id: int,
    data: dict = Body(...)
):
    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")
    try:
        query = """
        UPDATE gsm_lines
        SET line_name = $1, phone_number = $2, prefix = $3
        WHERE id = $4 AND enterprise_number = $5
        RETURNING id, line_id, internal_id, prefix, phone_number, line_name, in_schema, out_schema, shop, slot, redirect
        """
        row = await conn.fetchrow(
            query,
            data.get("line_name"),
            data.get("phone_number"),
            data.get("prefix"),
            line_id,
            enterprise_number
        )
        if not row:
            raise HTTPException(status_code=404, detail="–õ–∏–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
        return dict(row)
    finally:
        await conn.close()

@app.get("/enterprise/{enterprise_number}/audiofiles", response_class=JSONResponse)
async def get_audio_files(enterprise_number: str, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        query = """
        WITH schema_file_usage AS (
            -- –ò–∑–≤–ª–µ–∫–∞–µ–º —Ñ–∞–π–ª—ã –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–π
            SELECT
                ds.schema_name,
                (node.value -> 'data' -> 'greetingFile' ->> 'id')::int AS file_id
            FROM
                dial_schemas ds,
                json_array_elements(ds.schema_data -> 'nodes') AS node
            WHERE
                ds.enterprise_id = $1
                AND node.value ->> 'type' = 'greeting'
                AND node.value -> 'data' -> 'greetingFile' ->> 'id' IS NOT NULL

            UNION ALL

            -- –ò–∑–≤–ª–µ–∫–∞–µ–º —Ñ–∞–π–ª—ã –º—É–∑—ã–∫–∏ –Ω–∞ —É–¥–µ—Ä–∂–∞–Ω–∏–∏
            SELECT
                ds.schema_name,
                (node.value -> 'data' -> 'holdMusic' ->> 'id')::int AS file_id
            FROM
                dial_schemas ds,
                json_array_elements(ds.schema_data -> 'nodes') AS node
            WHERE
                ds.enterprise_id = $1
                AND node.value ->> 'type' = 'dial'
                AND node.value -> 'data' -> 'holdMusic' ->> 'type' = 'custom'
                AND node.value -> 'data' -> 'holdMusic' ->> 'id' IS NOT NULL
        ),
        aggregated_schemas AS (
            SELECT
                file_id,
                array_agg(DISTINCT schema_name) as used_in_schemas
            FROM schema_file_usage
            GROUP BY file_id
        )
        SELECT
            mf.id,
            mf.display_name,
            mf.file_type,
            mf.file_path,
            mf.original_filename,
            mf.created_at,
            COALESCE(ags.used_in_schemas, '{}'::text[]) as used_in_schemas
        FROM
            music_files mf
        LEFT JOIN aggregated_schemas ags ON mf.id = ags.file_id
        WHERE
            mf.enterprise_number = $1
        ORDER BY
            mf.created_at DESC;
        """
        files = await conn.fetch(query, enterprise_number)
        
        logger.info(f"AUDIO_LIST: –ù–∞–π–¥–µ–Ω–æ {len(files)} —Ñ–∞–π–ª–æ–≤ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}.")

        # Manually construct the response to handle datetime serialization
        result = [
            {
                "id": file["id"],
                "display_name": file["display_name"],
                "file_type": file["file_type"],
                "file_path": file["file_path"],
                "original_filename": file["original_filename"],
                "created_at": file["created_at"].isoformat(),
                "used_in_schemas": list(file["used_in_schemas"])
            }
            for file in files
        ]
        
        logger.info(f"AUDIO_LIST: –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–ø–∏—Å–∫–∞ —Ñ–∞–π–ª–æ–≤ –∫–ª–∏–µ–Ω—Ç—É: {result}")
        return JSONResponse(content=result)
    except Exception as e:
        logger.error(f"Could not fetch music files from DB: {e}")
        raise HTTPException(status_code=500, detail="–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∞—É–¥–∏–æ—Ñ–∞–π–ª–æ–≤.")
    finally:
        await conn.close()

@app.get("/audiofile/{file_id}")
async def stream_audio_file(file_id: int, current_enterprise: str = Depends(get_current_enterprise)):
    logger.info(f"AUDIO_STREAM: –ü–æ–ø—ã—Ç–∫–∞ –æ—Ç–¥–∞—Ç—å —Ñ–∞–π–ª id: {file_id} –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è: {current_enterprise}")
    relative_path_from_db = await get_file_path_from_db(file_id, current_enterprise)

    if not relative_path_from_db:
        logger.warning(f"AUDIO_STREAM: –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ë–î –¥–ª—è id: {file_id}, –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è: {current_enterprise}")
        raise HTTPException(status_code=404, detail="–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω (–æ—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –≤ –ë–î)")

    logger.info(f"AUDIO_STREAM: –ù–∞–π–¥–µ–Ω –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –≤ –ë–î: {relative_path_from_db}")
    
    # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –ø—É—Ç—å –≤ –∞–±—Å–æ–ª—é—Ç–Ω—ã–π
    absolute_path = PROJECT_ROOT / relative_path_from_db
    logger.info(f"AUDIO_STREAM: –°–∫–æ–Ω—Å—Ç—Ä—É–∏—Ä–æ–≤–∞–Ω –∞–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å: {absolute_path}")

    if not absolute_path.exists():
        logger.error(f"AUDIO_STREAM: –§–∞–π–ª –ù–ï —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–∞ –¥–∏—Å–∫–µ –ø–æ –∞–±—Å–æ–ª—é—Ç–Ω–æ–º—É –ø—É—Ç–∏: {absolute_path}. CWD: {os.getcwd()}")
        raise HTTPException(status_code=404, detail="–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω (–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –Ω–∞ –¥–∏—Å–∫–µ)")

    logger.info(f"AUDIO_STREAM: –û—Ç–¥–∞—é —Ñ–∞–π–ª {absolute_path} —Å media_type audio/wav")
    return FileResponse(str(absolute_path), media_type="audio/wav")

@app.post("/enterprise/{enterprise_number}/audiofiles", status_code=status.HTTP_201_CREATED)
async def upload_audio_file(
    enterprise_number: str,
    display_name: str = Form(...),
    file_type: str = Form(...),
    file: UploadFile = File(...),
    current_enterprise: str = Depends(get_current_enterprise)
):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    if file.content_type not in ["audio/mpeg", "audio/wav", "audio/x-wav"]:
        raise HTTPException(status_code=400, detail="–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –î–æ–ø—É—Å–∫–∞—é—Ç—Å—è .mp3 –∏ .wav")

    # Generate internal filename and path
    random_chars = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
    internal_filename = f"{random_chars}.wav" # Always save as wav
    
    base_dir = "music"
    enterprise_dir = os.path.join(base_dir, enterprise_number)
    file_type_dir = os.path.join(enterprise_dir, file_type)
    
    os.makedirs(file_type_dir, exist_ok=True)
    
    final_file_path = os.path.join(file_type_dir, internal_filename)
    temp_file_path = f"/tmp/{uuid.uuid4()}_{file.filename}"

    # Save uploaded file temporarily
    with open(temp_file_path, "wb") as buffer:
        buffer.write(await file.read())

    # Convert file with ffmpeg to wav, 16-bit, 8000Hz, mono
    # Asterisk requires this specific format
    ffmpeg_command = (
        f"ffmpeg -i {temp_file_path} -acodec pcm_s16le -ac 1 -ar 8000 "
        f"{final_file_path}"
    )

    process = await asyncio.create_subprocess_shell(
        ffmpeg_command,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    stdout, stderr = await process.communicate()

    # Clean up temp file
    os.remove(temp_file_path)

    if process.returncode != 0:
        logger.error(f"FFmpeg error: {stderr.decode()}")
        raise HTTPException(status_code=500, detail=f"–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ —Ñ–∞–π–ª–∞: {stderr.decode()}")

    # Insert into database
    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        query = """
        INSERT INTO music_files (enterprise_number, file_type, display_name, internal_filename, original_filename, file_path)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id, display_name, file_type, created_at
        """
        new_file_record = await conn.fetchrow(
            query,
            enterprise_number,
            file_type,
            display_name,
            internal_filename,
            file.filename,
            final_file_path
        )
        
        # --- –ù–û–í–ê–Ø –ê–†–•–ò–¢–ï–ö–¢–£–†–ê: –î–ï–ü–õ–û–ô –ù–ê –£–î–ê–õ–ï–ù–ù–´–ô –•–û–°–¢ ---
        # –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–µ–º —Ñ–∞–π–ª –Ω–∞ —É–¥–∞–ª–µ–Ω–Ω—ã–π —Ö–æ—Å—Ç —á–µ—Ä–µ–∑ –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å
        asyncio.create_task(_deploy_single_audio_file_to_asterisk(
            enterprise_number, final_file_path, file_type, internal_filename
        ))
        
        response_data = {
            "id": new_file_record["id"],
            "display_name": new_file_record["display_name"],
            "file_type": new_file_record["file_type"],
            "created_at": new_file_record["created_at"].isoformat()
        }
        return JSONResponse(content=response_data)
    except Exception as e:
        logger.error(f"Could not insert music file into DB: {e}")
        # Clean up created file if DB insert fails
        if os.path.exists(final_file_path):
            os.remove(final_file_path)
        raise HTTPException(status_code=500, detail="–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ñ–∞–π–ª–µ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö.")

@app.post("/enterprise/{enterprise_number}/regenerate-musiconhold-conf", status_code=status.HTTP_200_OK)
async def regenerate_musiconhold_conf(
    enterprise_number: str,
    current_enterprise: str = Depends(get_current_enterprise)
):
    """
    –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ—Ç —Ñ–∞–π–ª musiconhold.conf –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è.
    """
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        # –í—ã–∑—ã–≤–∞–µ–º –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è –∞—É–¥–∏–æ—Ñ–∞–π–ª–æ–≤
        deployment_result = await _deploy_all_audio_files_to_asterisk(enterprise_number)
        
        if deployment_result["success"]:
            logger.info(f"–£—Å–ø–µ—à–Ω–æ–µ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –∞—É–¥–∏–æ—Ñ–∞–π–ª–æ–≤ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}")
            return JSONResponse(content={
                "status": "success", 
                "detail": deployment_result["message"]
            })
        else:
            logger.warning(f"–†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–æ —Å –æ—à–∏–±–∫–∞–º–∏ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}: {deployment_result['message']}")
            return JSONResponse(content={
                "status": "warning", 
                "detail": deployment_result["message"]
            })
            
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–∏ –∞—É–¥–∏–æ—Ñ–∞–π–ª–æ–≤ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–∏ –∞—É–¥–∏–æ—Ñ–∞–π–ª–æ–≤.")
    finally:
        await conn.close()

@app.delete("/enterprise/{enterprise_number}/audiofiles/{file_id}", status_code=status.HTTP_200_OK)
async def delete_audio_file(
    enterprise_number: str,
    file_id: int,
    current_enterprise: str = Depends(get_current_enterprise)
):
    """
    –£–¥–∞–ª—è–µ—Ç –∞—É–¥–∏–æ—Ñ–∞–π–ª, –µ—Å–ª–∏ –æ–Ω –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–∏ –≤ –æ–¥–Ω–æ–π —Å—Ö–µ–º–µ.
    """
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —Ñ–∞–π–ª
        file_check = await conn.fetchrow(
            "SELECT id, file_path, display_name FROM music_files WHERE id = $1 AND enterprise_number = $2",
            file_id, enterprise_number
        )
        if not file_check:
            raise HTTPException(status_code=404, detail="–ê—É–¥–∏–æ—Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω")

        # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª –≤ —Å—Ö–µ–º–∞—Ö
        usage_check = await conn.fetchval("""
            SELECT COUNT(*) FROM dial_schemas 
            WHERE enterprise_id = $1 
            AND (
                schema_data::text LIKE '%"type": "custom"%' 
                AND schema_data::text LIKE $2
            )
        """, enterprise_number, f'%"id": {file_id}%')

        if usage_check > 0:
            raise HTTPException(status_code=400, detail="–ù–µ–ª—å–∑—è —É–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª, –∫–æ—Ç–æ—Ä—ã–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ —Å—Ö–µ–º–∞—Ö")

        # 3. –£–¥–∞–ª—è–µ–º —Ñ–∏–∑–∏—á–µ—Å–∫–∏–π —Ñ–∞–π–ª
        file_path = file_check['file_path']
        if os.path.exists(file_path):
            os.remove(file_path)
            logger.info(f"–§–∏–∑–∏—á–µ—Å–∫–∏–π —Ñ–∞–π–ª —É–¥–∞–ª–µ–Ω: {file_path}")

        # 4. –£–¥–∞–ª—è–µ–º –∑–∞–ø–∏—Å—å –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        await conn.execute(
            "DELETE FROM music_files WHERE id = $1 AND enterprise_number = $2",
            file_id, enterprise_number
        )

        # 5. –†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª—ã –Ω–∞ —É–¥–∞–ª–µ–Ω–Ω—ã–π —Ö–æ—Å—Ç
        asyncio.create_task(_deploy_all_audio_files_to_asterisk(enterprise_number))

        logger.info(f"–ê—É–¥–∏–æ—Ñ–∞–π–ª {file_check['display_name']} (ID: {file_id}) —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω")
        return JSONResponse(content={"message": f"–ê—É–¥–∏–æ—Ñ–∞–π–ª '{file_check['display_name']}' —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω"})

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∞—É–¥–∏–æ—Ñ–∞–π–ª–∞: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞")
    finally:
        await conn.close()

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
# Departments Management
# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

@app.get("/enterprise/{enterprise_number}/departments", response_class=JSONResponse)
async def get_departments(enterprise_number: str, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        query = """
        SELECT
            d.id,
            d.name,
            d.number
        FROM departments d
        WHERE d.enterprise_number = $1
        ORDER BY d.number
        """
        departments = await conn.fetch(query, enterprise_number)
        return [dict(row) for row in departments]
    finally:
        await conn.close()

@app.get("/enterprise/{enterprise_number}/departments/next-available-number", response_class=JSONResponse)
async def get_next_department_number(enterprise_number: str, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    
    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")
    
    try:
        query = "SELECT number FROM departments WHERE enterprise_number = $1"
        rows = await conn.fetch(query, enterprise_number)
        existing_numbers = {row['number'] for row in rows}
        
        for num in range(901, 1000):
            if num not in existing_numbers:
                return JSONResponse(content={"next_number": num})
        
        return JSONResponse(content={"error": "All department numbers are taken"}, status_code=404)
    finally:
        await conn.close()

@app.post("/enterprise/{enterprise_number}/departments", response_class=JSONResponse, status_code=status.HTTP_201_CREATED)
async def create_department(
    enterprise_number: str,
    department: DepartmentCreate,
    current_enterprise: str = Depends(get_current_enterprise)
):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        query = """
        INSERT INTO departments (enterprise_number, name, number)
        VALUES ($1, $2, $3)
        RETURNING id, name, number
        """
        new_department = await conn.fetchrow(query, enterprise_number, department.name, department.number)
        return dict(new_department)
    except asyncpg.exceptions.UniqueViolationError:
        raise HTTPException(status_code=400, detail="–û—Ç–¥–µ–ª —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º –∏–ª–∏ –Ω–æ–º–µ—Ä–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")
    except asyncpg.exceptions.CheckViolationError:
        raise HTTPException(status_code=400, detail="–ù–æ–º–µ—Ä –æ—Ç–¥–µ–ª–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç 901 –¥–æ 999.")
    except Exception as e:
        logger.error(f"Failed to create department: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞.")
    finally:
        await conn.close()

@app.get("/enterprise/{enterprise_number}/departments/{department_id}", response_class=JSONResponse)
async def get_department_details(enterprise_number: str, department_id: int, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        dept_query = "SELECT id, name, number FROM departments WHERE id = $1 AND enterprise_number = $2"
        department = await conn.fetchrow(dept_query, department_id, enterprise_number)

        if not department:
            raise HTTPException(status_code=404, detail="–û—Ç–¥–µ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω")

        members_query = """
        SELECT
            dm.internal_phone_id as id,
            (u.first_name || ' ' || u.last_name) AS user_name,
            uip.phone_number
        FROM department_members dm
        JOIN user_internal_phones uip ON dm.internal_phone_id = uip.id
        LEFT JOIN users u ON uip.user_id = u.id
        WHERE dm.department_id = $1
        ORDER BY u.last_name, u.first_name, uip.phone_number
        """
        members = await conn.fetch(members_query, department_id)
        
        result = dict(department)
        result['members'] = [dict(member) for member in members]
        
        return JSONResponse(content=result)
    finally:
        await conn.close()

@app.put("/enterprise/{enterprise_number}/departments/{department_id}", response_class=JSONResponse)
async def update_department(
    enterprise_number: str,
    department_id: int,
    department: DepartmentUpdate,
    current_enterprise: str = Depends(get_current_enterprise)
):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        async with conn.transaction():
            # Update department details
            updated_dept = await conn.fetchrow(
                """
                UPDATE departments SET name = $1, number = $2
                WHERE id = $3 AND enterprise_number = $4
                RETURNING id, name, number
                """,
                department.name, department.number, department_id, enterprise_number
            )
            if not updated_dept:
                raise HTTPException(status_code=404, detail="–û—Ç–¥–µ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.")

            # Mange members
            await conn.execute("DELETE FROM department_members WHERE department_id = $1", department_id)
            
            if department.members:
                # Prepare data for copy
                records_to_insert = [(department_id, member_id) for member_id in department.members]
                await conn.copy_records_to_table(
                    'department_members',
                    records=records_to_insert,
                    columns=['department_id', 'internal_phone_id']
                )

        # –ü–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –≤—ã–∑—ã–≤–∞–µ–º –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∫–æ–Ω—Ñ–∏–≥–∞
        try:
            async with httpx.AsyncClient() as client:
                plan_service_url = f"http://localhost:8006/generate_config"
                response = await client.post(plan_service_url, json={"enterprise_id": enterprise_number}, timeout=10.0)
                response.raise_for_status()
                logger.info(f"–£—Å–ø–µ—à–Ω–æ –≤—ã–∑–≤–∞–Ω —Å–µ—Ä–≤–∏—Å plan.py –¥–ª—è –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ñ–∏–≥–∞ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}.")
        except httpx.RequestError as e:
            logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–∑–≤–∞—Ç—å —Å–µ—Ä–≤–∏—Å plan.py –¥–ª—è –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ñ–∏–≥–∞: {e}")
            # –ù–µ –±—Ä–æ—Å–∞–µ–º –æ—à–∏–±–∫—É, —Ç–∞–∫ –∫–∞–∫ —É–¥–∞–ª–µ–Ω–∏–µ —É–∂–µ –ø—Ä–æ—à–ª–æ —É—Å–ø–µ—à–Ω–æ

        return JSONResponse(content=dict(updated_dept))
    except asyncpg.exceptions.UniqueViolationError:
        raise HTTPException(status_code=400, detail="–û—Ç–¥–µ–ª —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º –∏–ª–∏ –Ω–æ–º–µ—Ä–æ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç.")
    except asyncpg.exceptions.CheckViolationError:
        raise HTTPException(status_code=400, detail="–ù–æ–º–µ—Ä –æ—Ç–¥–µ–ª–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ –æ—Ç 901 –¥–æ 999.")
    except Exception as e:
        logger.error(f"Failed to update department: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –æ—Ç–¥–µ–ª–∞.")
    finally:
        await conn.close()

@app.delete("/enterprise/{enterprise_number}/departments/{department_id}")
async def delete_department(request: Request, enterprise_number: str, department_id: int):
    logger.info(f"–ü–æ–ª—É—á–µ–Ω –∑–∞–ø—Ä–æ—Å –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ –æ—Ç–¥–µ–ª–∞ {department_id} –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}")
    conn = await get_db_connection()
    try:
        async with conn.transaction():
            # –°–Ω–∞—á–∞–ª–∞ —É–¥–∞–ª—è–µ–º –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –æ—Ç–¥–µ–ª–∞ –∏–∑ department_members
            await conn.execute(
                'DELETE FROM department_members WHERE department_id = $1',
                department_id
            )
            logger.info(f"–£–¥–∞–ª–µ–Ω—ã —É—á–∞—Å—Ç–Ω–∏–∫–∏ –æ—Ç–¥–µ–ª–∞ {department_id}")

            # –ó–∞—Ç–µ–º —É–¥–∞–ª—è–µ–º —Å–∞–º –æ—Ç–¥–µ–ª
            result = await conn.execute(
                'DELETE FROM departments WHERE id = $1 RETURNING id',
                department_id
            )
            if not result or result.strip() == 'DELETE 0':
                raise HTTPException(status_code=404, detail="–û—Ç–¥–µ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω")
            
            logger.info(f"–£–¥–∞–ª–µ–Ω –æ—Ç–¥–µ–ª {department_id}")

        # –ü–æ—Å–ª–µ —É—Å–ø–µ—à–Ω–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –≤—ã–∑—ã–≤–∞–µ–º –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∫–æ–Ω—Ñ–∏–≥–∞
        try:
            async with httpx.AsyncClient() as client:
                plan_service_url = f"http://localhost:8006/generate_config"
                response = await client.post(plan_service_url, json={"enterprise_id": enterprise_number}, timeout=10.0)
                response.raise_for_status()
                logger.info(f"–£—Å–ø–µ—à–Ω–æ –≤—ã–∑–≤–∞–Ω —Å–µ—Ä–≤–∏—Å plan.py –¥–ª—è –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ñ–∏–≥–∞ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}.")
        except httpx.RequestError as e:
            logger.error(f"–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–∑–≤–∞—Ç—å —Å–µ—Ä–≤–∏—Å plan.py –¥–ª—è –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ñ–∏–≥–∞: {e}")
            # –ù–µ –±—Ä–æ—Å–∞–µ–º –æ—à–∏–±–∫—É, —Ç–∞–∫ –∫–∞–∫ —É–¥–∞–ª–µ–Ω–∏–µ —É–∂–µ –ø—Ä–æ—à–ª–æ —É—Å–ø–µ—à–Ω–æ

        return JSONResponse(content={"message": "–û—Ç–¥–µ–ª —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω"}, status_code=200)

    except HTTPException as e:
        # –õ–æ–≥–∏—Ä—É–µ–º –∏ –ø–µ—Ä–µ–≤—ã–±—Ä–∞—Å—ã–≤–∞–µ–º, —á—Ç–æ–±—ã FastAPI –æ–±—Ä–∞–±–æ—Ç–∞–ª
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –æ—Ç–¥–µ–ª–∞: {e.detail}")
        raise e
    except Exception as e:
        logger.error(f"–ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –æ—Ç–¥–µ–ª–∞ {department_id}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞")
    finally:
        await conn.close()

# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
# SIP Lines Management
# ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

@app.get("/enterprise/{enterprise_number}/sip-providers", response_class=JSONResponse)
async def get_sip_providers(enterprise_number: str, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")
    try:
        query = "SELECT id, name FROM sip ORDER BY name"
        providers = await conn.fetch(query)
        return [dict(row) for row in providers]
    finally:
        await conn.close()

@app.get("/enterprise/{enterprise_number}/sip-lines", response_class=JSONResponse)
async def get_sip_lines(enterprise_number: str, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        query = """
        SELECT
            su.id,
            su.line_name,
            su.prefix,
            p.name as provider_name,
            su.in_schema as incoming_schema_name,
            COALESCE(out_s.outgoing_schema_names, ARRAY[]::text[]) as outgoing_schema_names
        FROM
            sip_unit su
        LEFT JOIN
            sip p ON su.provider_id = p.id
        LEFT JOIN (
            SELECT
                sosa.sip_line_name,
                array_agg(sosa.schema_name) as outgoing_schema_names
            FROM
                sip_outgoing_schema_assignments sosa
            WHERE
                sosa.enterprise_number = $1
            GROUP BY
                sosa.sip_line_name
        ) out_s ON su.line_name = out_s.sip_line_name
        WHERE
            su.enterprise_number = $1
        ORDER BY
            su.id;
        """
        sip_lines = await conn.fetch(query, enterprise_number)
        logger.info(f"–ü–û–õ–£–ß–ï–ù–û –ò–ó –ë–î: {len(sip_lines)} —Å—Ç—Ä–æ–∫.")
        logger.info(f"–°–û–î–ï–†–ñ–ò–ú–û–ï: {sip_lines}")

        results = []
        for record in sip_lines:
            # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–∞–∂–¥—É—é –∑–∞–ø–∏—Å—å –≤ —Å–ª–æ–≤–∞—Ä—å.
            # –ü–æ–ª—è-–º–∞—Å—Å–∏–≤—ã Postgres (–∫–∞–∫ `outgoing_schema_names`) asyncpg –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫–∞–∫ —Å–ø–∏—Å–∫–∏ Python,
            # —á—Ç–æ —Å–æ–≤–º–µ—Å—Ç–∏–º–æ —Å JSON. –ü—Ä–æ–±–ª–µ–º–∞ –º–æ–≥–ª–∞ –±—ã—Ç—å –≤ –¥—Ä—É–≥–æ–º.
            # –ù–æ –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ—Å—Ç–∏ –æ—Å—Ç–∞–≤–ª—è–µ–º —è–≤–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ dict.
            results.append(dict(record))
        return results
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö –≤ get_sip_lines: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")
    finally:
        await conn.close()

@app.get("/enterprise/{enterprise_number}/sip-lines/{line_id}", response_class=JSONResponse)
async def get_sip_line_details(enterprise_number: str, line_id: int, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        query = "SELECT id, line_name, password, prefix, provider_id FROM sip_unit WHERE id = $1 AND enterprise_number = $2"
        line = await conn.fetchrow(query, line_id, enterprise_number)
        if not line:
            raise HTTPException(status_code=404, detail="SIP line not found")
        return dict(line)
    finally:
        await conn.close()

@app.put("/enterprise/{enterprise_number}/sip-lines/{line_id}", response_class=JSONResponse)
async def update_sip_line(
    enterprise_number: str,
    line_id: int,
    data: SipLineUpdate,
    current_enterprise: str = Depends(get_current_enterprise)
):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        async with conn.transaction():
            shablon = await conn.fetchval("SELECT shablon FROM sip WHERE id = $1", data.provider_id)
            if not shablon:
                raise HTTPException(status_code=404, detail="–®–∞–±–ª–æ–Ω –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ SIP-–ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            
            info_text = shablon.replace("LOGIN", data.line_name).replace("PASSWORD", data.password)
            
            query = """
            UPDATE sip_unit
            SET line_name = $1, password = $2, prefix = $3, info = $4, provider_id = $5
            WHERE id = $6 AND enterprise_number = $7
            RETURNING id, enterprise_number, line_name, prefix
            """
            updated_line = await conn.fetchrow(
                query,
                data.line_name, data.password, data.prefix,
                info_text, data.provider_id, line_id, enterprise_number
            )
            
            if not updated_line:
                raise HTTPException(status_code=404, detail="SIP line not found for update")

        # –†–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è SIP –∫–æ–Ω—Ñ–∏–≥–∞ —á–µ—Ä–µ–∑ –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ)
        asyncio.create_task(_regenerate_sip_config_via_plan_service(enterprise_number))

        return dict(updated_line)

    except asyncpg.exceptions.UniqueViolationError:
        raise HTTPException(status_code=400, detail="–õ–∏–Ω–∏—è —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –¥–ª—è —ç—Ç–æ–≥–æ –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è.")
    except Exception as e:
        logger.error(f"Failed to update SIP line: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ SIP-–ª–∏–Ω–∏–∏.")
    finally:
        await conn.close()

@app.post("/enterprise/{enterprise_number}/sip-lines", response_class=JSONResponse, status_code=status.HTTP_201_CREATED)
async def create_sip_line(
    enterprise_number: str,
    data: SipLineCreate,
    current_enterprise: str = Depends(get_current_enterprise)
):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        # 1. Get the template from the sip table
        shablon = await conn.fetchval("SELECT shablon FROM sip WHERE id = $1", data.provider_id)
        if not shablon:
            raise HTTPException(status_code=404, detail="–®–∞–±–ª–æ–Ω –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ SIP-–ø—Ä–æ–≤–∞–π–¥–µ—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        
        # 2. Replace placeholders
        info_text = shablon.replace("LOGIN", data.line_name).replace("PASSWORD", data.password)
        
        # 3. Insert the new record into the sip_unit table
        query = """
        INSERT INTO sip_unit (enterprise_number, line_name, password, prefix, info, provider_id)
        VALUES ($1, $2, $3, $4, $5, $6)
        RETURNING id, enterprise_number, line_name, prefix
        """
        new_line_record = await conn.fetchrow(
            query,
            enterprise_number,
            data.line_name,
            data.password,
            data.prefix,
            info_text,
            data.provider_id
        )

        # –†–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è SIP –∫–æ–Ω—Ñ–∏–≥–∞ —á–µ—Ä–µ–∑ –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ)
        asyncio.create_task(_regenerate_sip_config_via_plan_service(enterprise_number))
        
        return dict(new_line_record)

    except asyncpg.exceptions.UniqueViolationError:
        raise HTTPException(status_code=400, detail="–õ–∏–Ω–∏—è —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –¥–ª—è —ç—Ç–æ–≥–æ –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è.")
    except Exception as e:
        logger.error(f"Failed to create SIP line: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ SIP-–ª–∏–Ω–∏–∏.")
    finally:
        await conn.close()

@app.get("/enterprise/{enterprise_number}/internal-phones/{phone_number}/details", response_class=JSONResponse)
async def get_internal_phone_details(enterprise_number: str, phone_number: str, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    
    conn = await get_db_connection()
    if not conn: raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        query = "SELECT phone_number, password FROM user_internal_phones WHERE enterprise_number = $1 AND phone_number = $2"
        phone_details = await conn.fetchrow(query, enterprise_number, phone_number)

        if not phone_details:
            raise HTTPException(status_code=404, detail="Internal phone not found")

        return JSONResponse(content=dict(phone_details))
    finally:
        await conn.close()

@app.delete("/enterprise/{enterprise_number}/internal-phones/{phone_number}", response_class=Response)
async def delete_internal_phone(enterprise_number: str, phone_number: str, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        # –ü–æ–ª—É—á–∞–µ–º –∑–∞–ø–∏—Å—å –æ —Ç–µ–ª–µ—Ñ–æ–Ω–µ, –≤–∫–ª—é—á–∞—è –µ–≥–æ id –∏ user_id
        phone_record = await conn.fetchrow("SELECT id, user_id FROM user_internal_phones WHERE enterprise_number = $1 AND phone_number = $2", enterprise_number, phone_number)

        if not phone_record:
            raise HTTPException(status_code=404, detail="–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –Ω–æ–º–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω.")

        phone_id = phone_record['id']
        assigned_user = phone_record['user_id']
        
        # 1. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –ø—Ä–∏–≤—è–∑–∞–Ω –ª–∏ –Ω–æ–º–µ—Ä –∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
        if assigned_user is not None:
            raise HTTPException(status_code=409, detail=f"–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –Ω–æ–º–µ—Ä {phone_number}, —Ç–∞–∫ –∫–∞–∫ –æ–Ω –Ω–∞–∑–Ω–∞—á–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é.")

        # 2. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ª–∏ –Ω–æ–º–µ—Ä –≤–æ –≤—Ö–æ–¥—è—â–∏—Ö —Å—Ö–µ–º–∞—Ö, –∏—Å–ø–æ–ª—å–∑—É—è phone_id
        incoming_schemas = await conn.fetch(
            "SELECT ds.schema_name FROM dial_schemas ds JOIN user_internal_phone_incoming_assignments uipa ON ds.schema_id = uipa.schema_id WHERE uipa.internal_phone_id = $1 AND ds.enterprise_id = $2",
            phone_id, enterprise_number)
        
        # 3. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ª–∏ –Ω–æ–º–µ—Ä –≤ –∏—Å—Ö–æ–¥—è—â–∏—Ö —Å—Ö–µ–º–∞—Ö
        outgoing_schemas = await conn.fetch(
            "SELECT ds.schema_name FROM user_internal_phones uip JOIN dial_schemas ds ON uip.outgoing_schema_id = ds.schema_id WHERE uip.id = $1 AND uip.enterprise_number = $2",
            phone_id, enterprise_number)

        conflicts = []
        if incoming_schemas:
            conflicts.append(f"–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤–æ –≤—Ö–æ–¥—è—â–∏—Ö —Å—Ö–µ–º–∞—Ö: {', '.join([s['schema_name'] for s in incoming_schemas])}")
        if outgoing_schemas:
            conflicts.append(f"–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –∏—Å—Ö–æ–¥—è—â–∏—Ö —Å—Ö–µ–º–∞—Ö: {', '.join([s['schema_name'] for s in outgoing_schemas])}")

        if conflicts:
            error_message = f"–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å –Ω–æ–º–µ—Ä {phone_number}, —Ç–∞–∫ –∫–∞–∫ –æ–Ω " + " –∏ ".join(conflicts) + "."
            raise HTTPException(status_code=409, detail=error_message)

        # –ï—Å–ª–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–æ–π–¥–µ–Ω—ã, —É–¥–∞–ª—è–µ–º –Ω–æ–º–µ—Ä –ø–æ –µ–≥–æ ID
        delete_query = "DELETE FROM user_internal_phones WHERE id = $1"
        result = await conn.execute(delete_query, phone_id)

        if result.strip() == "DELETE 0":
             raise HTTPException(status_code=404, detail="–ù–æ–º–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")

        # –†–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è SIP –∫–æ–Ω—Ñ–∏–≥–∞ —á–µ—Ä–µ–∑ –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ)
        asyncio.create_task(_regenerate_sip_config_via_plan_service(enterprise_number))

        return Response(status_code=status.HTTP_204_NO_CONTENT)

    except HTTPException as http_exc:
        raise http_exc # Re-raise HTTPException to be handled by FastAPI
    except Exception as e:
        logger.error(f"Error deleting internal phone {phone_number} for enterprise {enterprise_number}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞. –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –Ω–æ–º–µ—Ä.")
    finally:
        await conn.close()

@app.post("/enterprise/{enterprise_number}/regenerate-config", status_code=status.HTTP_200_OK)
async def regenerate_config(
    enterprise_number: str,
    current_enterprise: str = Depends(get_current_enterprise)
):
    """
    –≠—Ç–æ—Ç —ç–Ω–¥–ø–æ–∏–Ω—Ç –≤—ã–∑—ã–≤–∞–µ—Ç –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å –¥–ª—è –ø–æ–ª–Ω–æ–π —Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ extensions.conf
    –∏ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è –µ–≥–æ –Ω–∞ —É–¥–∞–ª–µ–Ω–Ω—ã–π Asterisk —Ö–æ—Å—Ç.
    """
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    
    try:
        # –í—ã–∑—ã–≤–∞–µ–º –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥–∞
        async with httpx.AsyncClient() as client:
            plan_service_url = f"http://localhost:8006/generate_config"
            response = await client.post(
                plan_service_url, 
                json={"enterprise_id": enterprise_number}, 
                timeout=30.0  # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º timeout –¥–ª—è SSH –æ–ø–µ—Ä–∞—Ü–∏–π
            )
            response.raise_for_status()
            result = response.json()
            
            # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç –æ—Ç –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å–∞
            deployment_info = result.get("deployment", {})
            deployment_success = deployment_info.get("success", False)
            deployment_message = deployment_info.get("message", "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞")
            
            if deployment_success:
                logger.info(f"–£—Å–ø–µ—à–Ω–∞—è —Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥–∞ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}")
                return {
                    "status": "success", 
                    "detail": "–°—Ö–µ–º—ã –∑–≤–æ–Ω–∫–æ–≤ –æ–±–Ω–æ–≤–ª–µ–Ω—ã"
                }
            else:
                logger.warning(f"–ö–æ–Ω—Ñ–∏–≥ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω, –Ω–æ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}: {deployment_message}")
                return {
                    "status": "warning", 
                    "detail": "–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ"
                }
                
    except httpx.TimeoutException:
        logger.error(f"Timeout –ø—Ä–∏ –≤—ã–∑–æ–≤–µ –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å–∞ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}")
        raise HTTPException(status_code=408, detail="–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ")
    except httpx.RequestError as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å–∞ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}: {e}")
        raise HTTPException(status_code=500, detail="–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ")
    except Exception as e:
        logger.error(f"–ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ñ–∏–≥–∞ –¥–ª—è –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è {enterprise_number}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="–ù–µ—Ç —Å–≤—è–∑–∏ —Å –ê–¢–°, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –ø–æ–∑–∂–µ")

@app.get("/enterprise/{enterprise_number}/dial-schemas", response_class=JSONResponse)
async def get_dial_schemas(enterprise_number: str, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    
    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        query = """
        SELECT id, name FROM dial_schemas WHERE enterprise_id = $1
        """
        schemas = await conn.fetch(query, enterprise_number)
        return [dict(row) for row in schemas]
    finally:
        await conn.close()

@app.delete("/enterprise/{enterprise_number}/sip-lines/{line_id}", response_class=Response)
async def delete_sip_line(enterprise_number: str, line_id: int, current_enterprise: str = Depends(get_current_enterprise)):
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")

    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        # 1. –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ SIP-–ª–∏–Ω–∏–∏, –≤–∫–ª—é—á–∞—è –µ–µ –∏–º—è –∏ –≤—Ö–æ–¥—è—â—É—é —Å—Ö–µ–º—É
        line_info = await conn.fetchrow("SELECT line_name, in_schema FROM sip_unit WHERE id = $1 AND enterprise_number = $2", line_id, enterprise_number)

        if not line_info:
            raise HTTPException(status_code=404, detail="SIP-–ª–∏–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")

        line_name = line_info['line_name']
        incoming_schema = line_info['in_schema']

        conflicts = []

        # 2. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –ø—Ä–∏–≤—è–∑–∞–Ω–∞ –ª–∏ –ª–∏–Ω–∏—è –∫ –≤—Ö–æ–¥—è—â–µ–π —Å—Ö–µ–º–µ
        if incoming_schema:
            conflicts.append(f"–í—Ö–æ–¥—è—â–∞—è —Å—Ö–µ–º–∞: {incoming_schema}")

        # 3. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ª–∏ –ª–∏–Ω–∏—è –≤ –∏—Å—Ö–æ–¥—è—â–∏—Ö —Å—Ö–µ–º–∞—Ö
        outgoing_schemas = await conn.fetch(
            "SELECT schema_name FROM sip_outgoing_schema_assignments WHERE sip_line_name = $1 AND enterprise_number = $2",
            line_name, enterprise_number
        )
        
        if outgoing_schemas:
            for s in outgoing_schemas:
                conflicts.append(f"–ò—Å—Ö–æ–¥—è—â–∞—è —Å—Ö–µ–º–∞: {s['schema_name']}")
        
        # 4. –ï—Å–ª–∏ –µ—Å—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã, –≤–µ—Ä–Ω—É—Ç—å –æ—à–∏–±–∫—É
        if conflicts:
            details = f"–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ —É–¥–∞–ª–∏—Ç—å SIP-–ª–∏–Ω–∏—é '{line_name}', —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ —Å–ª–µ–¥—É—é—â–∏—Ö —Å—Ö–µ–º–∞—Ö: " + ", ".join(conflicts)
            raise HTTPException(status_code=409, detail=details)

        # 5. –ï—Å–ª–∏ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤ –Ω–µ—Ç, —É–¥–∞–ª–∏—Ç—å –ª–∏–Ω–∏—é
        await conn.execute("DELETE FROM sip_unit WHERE id = $1 AND enterprise_number = $2", line_id, enterprise_number)
        
        # –†–µ–≥–µ–Ω–µ—Ä–∞—Ü–∏—è SIP –∫–æ–Ω—Ñ–∏–≥–∞ —á–µ—Ä–µ–∑ –ø–ª–∞–Ω-—Å–µ—Ä–≤–∏—Å (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ)
        asyncio.create_task(_regenerate_sip_config_via_plan_service(enterprise_number))
        
        return Response(status_code=status.HTTP_204_NO_CONTENT)

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to delete SIP line: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞.")
    finally:
        await conn.close()

@app.get("/enterprise/{enterprise_number}/phone-config-data", response_class=JSONResponse)
async def get_phone_config_data(enterprise_number: str, current_enterprise: str = Depends(get_current_enterprise)):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ç–µ–ª–µ—Ñ–æ–Ω–∞"""
    if enterprise_number != current_enterprise:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Access denied")
    
    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="DB connection failed")

    try:
        # –ü–æ–ª—É—á–∞–µ–º IP –∞–¥—Ä–µ—Å –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è
        enterprise_query = "SELECT ip FROM enterprises WHERE number = $1"
        enterprise_row = await conn.fetchrow(enterprise_query, enterprise_number)
        
        if not enterprise_row or not enterprise_row['ip']:
            raise HTTPException(status_code=404, detail="IP –∞–¥—Ä–µ—Å –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω")
        
        host_ip = enterprise_row['ip']
        
        # SSH –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        commands = {
            'sip_conf': f"sshpass -p '5atx9Ate@pbx' ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -p 5059 root@{host_ip} 'cat /etc/asterisk/sip.conf | grep -E \"(externip|bindport)\"'",
            'interfaces': f"sshpass -p '5atx9Ate@pbx' ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o LogLevel=ERROR -p 5059 root@{host_ip} 'cat /etc/network/interfaces | grep address'"
        }
        
        config_data = {}
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º SSH –∫–æ–º–∞–Ω–¥—ã
        for key, command in commands.items():
            try:
                process = await asyncio.create_subprocess_shell(
                    command,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=10)
                
                if process.returncode == 0:
                    config_data[key] = stdout.decode('utf-8').strip()
                else:
                    config_data[key] = ''
                    
            except asyncio.TimeoutError:
                config_data[key] = ''
            except Exception as e:
                logger.error(f"Error executing SSH command for {key}: {e}")
                config_data[key] = ''
        
        # –ü–∞—Ä—Å–∏–º –¥–∞–Ω–Ω—ã–µ –∏–∑ sip.conf
        sip_conf_content = config_data.get('sip_conf', '')
        externip = None
        bindport = '5060'
        has_externip = False
        
        for line in sip_conf_content.split('\n'):
            line = line.strip()
            if line.startswith('externip='):
                externip = line.split('=')[1].strip()
                has_externip = True
            elif line.startswith('bindport='):
                bindport = line.split('=')[1].strip()
        
        # –ü–∞—Ä—Å–∏–º –ª–æ–∫–∞–ª—å–Ω—ã–π IP –∏–∑ interfaces
        interfaces_content = config_data.get('interfaces', '')
        local_ip = None
        
        for line in interfaces_content.split('\n'):
            line = line.strip()
            if 'address' in line:
                parts = line.split()
                if len(parts) >= 2:
                    local_ip = parts[1].strip()
                    break
        
        return JSONResponse(content={
            'externip': externip,
            'bindport': bindport,
            'localIp': local_ip,
            'hasExternip': has_externip
        })
        
    except asyncio.TimeoutError:
        raise HTTPException(status_code=408, detail=f"–¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏ –∫ —Ö–æ—Å—Ç—É {host_ip}")
    except Exception as e:
        logger.error(f"Error getting phone config data for enterprise {enterprise_number}: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö: {str(e)}")
    finally:
        await conn.close()

@app.get("/admin/check-internal-phones-ip/{enterprise_number}", response_class=JSONResponse)
async def check_internal_phones_ip(enterprise_number: str):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ IP –∞–¥—Ä–µ—Å–æ–≤ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –ª–∏–Ω–∏–π –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏—è"""
    import asyncio
    from datetime import datetime
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏–∏
        conn = await get_db_connection()
        if not conn:
            raise HTTPException(status_code=500, detail="DB connection failed")
        
        try:
            enterprise_query = "SELECT ip FROM enterprises WHERE number = $1"
            enterprise_record = await conn.fetchrow(enterprise_query, enterprise_number)
            
            if not enterprise_record:
                return JSONResponse({'success': False, 'error': 'Enterprise not found'}, status_code=404)
                
            enterprise_ip = enterprise_record['ip']
            if not enterprise_ip:
                return JSONResponse({'success': False, 'error': 'Enterprise IP not configured'}, status_code=400)
            
            # SSH –∫–æ–º–∞–Ω–¥–∞ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Ç–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ SIP peers
            cmd = [
                'sshpass', '-p', '5atx9Ate@pbx',
                'ssh', 
                '-o', 'ConnectTimeout=5',
                '-o', 'StrictHostKeyChecking=no',
                '-o', 'UserKnownHostsFile=/dev/null',
                '-o', 'LogLevel=ERROR',
                '-p', '5059',
                f'root@{enterprise_ip}',
                'timeout 15 asterisk -rx "sip show peers"'
            ]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            try:
                stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=15.0)
                
                if process.returncode != 0:
                    error_output = stderr.decode('utf-8', errors='ignore')
                    return JSONResponse({
                        'success': False, 
                        'error': f'SSH command failed: {error_output.strip() or "Unknown error"}'
                    }, status_code=500)
                
                # –ü–∞—Ä—Å–∏–º –≤—ã–≤–æ–¥ –∫–æ–º–∞–Ω–¥—ã sip show peers
                output = stdout.decode('utf-8', errors='ignore')
                lines = output.strip().split('\n')
                
                internal_phones = {}
                
                for line in lines:
                    # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ –∏ —Å–ª—É–∂–µ–±–Ω—ã–µ —Å—Ç—Ä–æ–∫–∏
                    if 'Name/username' in line or 'sip peers' in line or not line.strip():
                        continue
                    
                    # –ü–∞—Ä—Å–∏–º —Å—Ç—Ä–æ–∫—É: "150/150         (Unspecified)    D  No         No             0    UNREACHABLE"
                    # –∏–ª–∏: "151/151         192.168.1.100    D  Yes        Yes            0    OK (1 ms)"
                    parts = line.split()
                    if len(parts) < 6:
                        continue
                    
                    name_part = parts[0]  # –ù–∞–ø—Ä–∏–º–µ—Ä: "150/150"
                    ip_part = parts[1] if len(parts) > 1 else "(Unspecified)"
                    
                    # –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–æ–º–µ—Ä –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π –ª–∏–Ω–∏–∏
                    peer_name = name_part.split('/')[0]
                    
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –ª–∏–Ω–∏—è (3-–∑–Ω–∞—á–Ω–∞—è, –∫—Ä–æ–º–µ 301/302)
                    if len(peer_name) == 3 and peer_name.isdigit() and peer_name not in ['301', '302']:
                        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
                        status = 'online' if ' OK ' in line else 'offline'
                        
                        # –ò–∑–≤–ª–µ–∫–∞–µ–º IP –∞–¥—Ä–µ—Å
                        if ip_part == '(Unspecified)' or ip_part == 'Unspecified':
                            ip_address = None
                        else:
                            # IP –º–æ–∂–µ—Ç –±—ã—Ç—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ "192.168.1.100:5060" –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ "192.168.1.100"
                            ip_address = ip_part.split(':')[0]
                        
                        internal_phones[peer_name] = {
                            'phone_number': peer_name,
                            'ip_address': ip_address,
                            'status': status,
                            'raw_line': line.strip()
                        }
                
                logger.info(f"Found {len(internal_phones)} internal phones for enterprise {enterprise_number}")
                
                return JSONResponse({
                    'success': True,
                    'enterprise_number': enterprise_number,
                    'enterprise_ip': enterprise_ip,
                    'internal_phones': internal_phones,
                    'total_found': len(internal_phones),
                    'checked_at': datetime.now().isoformat()
                })
                
            except asyncio.TimeoutError:
                return JSONResponse({
                    'success': False, 
                    'error': 'SSH connection timeout'
                }, status_code=500)
                
        finally:
            await conn.close()
            
    except Exception as e:
        logger.error(f"Error checking internal phones IP for enterprise {enterprise_number}: {e}", exc_info=True)
        return JSONResponse({
            'success': False,
            'error': str(e)
        }, status_code=500)

@app.get("/telegram-users")
async def get_telegram_users():
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å Telegram-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–µ–π"""
    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="Database connection error")
    
    try:
        users = await conn.fetch("""
            SELECT u.id, u.email, u.first_name, u.last_name, u.enterprise_number,
                   u.telegram_authorized, u.telegram_tg_id, u.personal_phone,
                   e.name as enterprise_name
            FROM users u
            JOIN enterprises e ON u.enterprise_number = e.number
            WHERE u.telegram_authorized = TRUE
            ORDER BY u.enterprise_number, u.last_name, u.first_name
        """)
        
        return [dict(user) for user in users]
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è Telegram –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
        raise HTTPException(status_code=500, detail="Database error")
    finally:
        await conn.close()

@app.post("/revoke-telegram-auth/{user_id}")
async def revoke_telegram_auth(user_id: int):
    """–û—Ç–∑—ã–≤ Telegram-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¥–ª—è –∞–¥–º–∏–Ω–æ–≤)"""
    conn = await get_db_connection()
    if not conn:
        raise HTTPException(status_code=500, detail="Database connection error")
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º telegram_tg_id –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º
        user = await conn.fetchrow(
            "SELECT telegram_tg_id FROM users WHERE id = $1", user_id
        )
        
        if not user or not user['telegram_tg_id']:
            return {"success": False, "message": "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω –≤ Telegram"}
        
        # –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—é
        await conn.execute("""
            UPDATE users 
            SET telegram_authorized = FALSE,
                telegram_tg_id = NULL,
                telegram_auth_code = NULL,
                telegram_auth_expires = NULL
            WHERE id = $1
        """, user_id)
        
        # –£–¥–∞–ª—è–µ–º –∏–∑ telegram_users
        await conn.execute("""
            DELETE FROM telegram_users WHERE tg_id = $1
        """, user['telegram_tg_id'])
        
        return {"success": True, "message": "Telegram-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –æ—Ç–æ–∑–≤–∞–Ω–∞"}
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ—Ç–∑—ã–≤–∞ Telegram-–∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏: {e}")
        return {"success": False, "message": "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞"}
    finally:
        await conn.close()

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8004) 